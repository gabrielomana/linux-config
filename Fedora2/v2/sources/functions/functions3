#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

#===============================================================================
# Archivo: functions3
# Proyecto: Fedora Post-Install (KDE)
# Descripci√≥n: Funciones reutilizables, refactorizadas y modulares
# Autor: Gabriel Oma√±a / Initium
# Licencia: MIT
#===============================================================================

# ‚îÄ‚îÄ‚îÄ Protecci√≥n contra ejecuci√≥n directa ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "[ERROR] Este archivo es un m√≥dulo de funciones y no debe ejecutarse directamente."
  echo "        Por favor, incl√∫yelo con: source ${BASH_SOURCE[0]}"
  exit 1
fi

# ‚îÄ‚îÄ‚îÄ Variables globales y rutas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
LISTS_DIR="${SCRIPT_DIR}/sources/lists"
LOG_DIR="$HOME/fedora_logs"
LOG_FILE="${LOG_DIR}/pkg_manager.log"

LIST_KDE_PLASMA="${LISTS_DIR}/kde_plasma.list"
LIST_KDE_APPS="${LISTS_DIR}/kde_plasma_apps.list"
LIST_KDE_BLOATWARE="${LISTS_DIR}/kde_bloatware.list"
LIST_MULTIMEDIA="${LISTS_DIR}/multimedia.list"
LIST_CODECS="${LISTS_DIR}/codecs.list"
LIST_UTILITIES="${LISTS_DIR}/utilities.list"
LIST_EXTRA_APPS="${LISTS_DIR}/extra_apps.list"
LIST_XORG_WORKSPACE="${LISTS_DIR}/plasma_xorg_full.list"
LIST_CLI_TOOLS="${LISTS_DIR}/cli_tools.list"

REQUIRED_LISTS=(
  "$LIST_KDE_PLASMA"
  "$LIST_KDE_APPS"
  "$LIST_KDE_BLOATWARE"
  "$LIST_MULTIMEDIA"
  "$LIST_CODECS"
  "$LIST_UTILITIES"
  "$LIST_EXTRA_APPS"
  "$LIST_XORG_WORKSPACE"
)

# ‚îÄ‚îÄ‚îÄ Validaci√≥n de listas necesarias ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
for list_file in "${REQUIRED_LISTS[@]}"; do
  [[ -f "$list_file" ]] || {
    echo "[ERROR] Lista no encontrada: $list_file"
    exit 1
  }
done

# ‚îÄ‚îÄ‚îÄ Colores ANSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if [[ -t 1 ]]; then
  RED="\033[0;31m"
  GREEN="\033[0;32m"
  YELLOW="\033[1;33m"
  BLUE="\033[1;34m"
  BOLD="\033[1m"
  NC="\033[0m"
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; BOLD=""; NC=""
fi

# ‚îÄ‚îÄ‚îÄ Logging y utilidades base ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
mkdir -p "$LOG_DIR"
touch "$LOG_FILE"

log_info()    { echo -e "${BLUE}[INFO]    $*${NC}"; }
log_warn()    { echo -e "${YELLOW}[WARN]    $*${NC}"; }
log_error()   { echo -e "${RED}[ERROR]   $*${NC}" >&2; ((ERROR_COUNT++)) || true; }
log_success() { echo -e "${GREEN}[OK]      $*${NC}"; }
log_section() {
  local title="$1"
  local clean_title="${title//[$'\t\r\n']}"
  local visual_width=${#clean_title}
  local padding=4
  local total_width=$((visual_width + padding))
  local border
  border=$(printf '‚îÄ%.0s' $(seq 1 "$total_width"))
  echo -e "\n${BLUE}‚îå$border‚îê${NC}"
  echo -e "${BLUE}‚îÇ  ${BOLD}${title}${NC}${BLUE}  ‚îÇ${NC}"
  echo -e "${BLUE}‚îî$border‚îò${NC}\n"
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECTION] $title" >> "$LOG_FILE"
}

#===============================================================================
# Funciones utilitarias generales
#===============================================================================

check_command() {
  command -v "$1" &>/dev/null || {
    log_error "Comando requerido no disponible: $1"
    return 1
  }
}

ensure_file_exists() {
  local file="$1"
  [[ -f "$file" ]] || {
    log_error "Archivo no encontrado: $file"
    return 1
  }
}

run_sudo() {
  if ! sudo -n true 2>/dev/null; then
    log_warn "Se requiere autenticaci√≥n sudo..."
    sudo -v || {
      log_error "No se pudo elevar a sudo. Abortando."
      exit 1
    }
  fi
}

is_root() {
  [[ "$EUID" -eq 0 ]]
}

draw_progress_bar() {
  local current=$1
  local total=$2
  local width=40
  local percent=$(( current * 100 / total ))
  local filled=$(( current * width / total ))
  local empty=$(( width - filled ))
  local progress_bar
  progress_bar=$(printf "%-${filled}s" "#" | tr ' ' '#')
  progress_bar+=$(printf "%-${empty}s" "-" | tr ' ' '-')
  printf "\r[%s] %3d%% (%d/%d)" "$progress_bar" "$percent" "$current" "$total"
  [[ "$current" -eq "$total" ]] && echo ""
}

try_cmd() {
  local desc="$1"; shift
  if "$@"; then
    log_success "‚úîÔ∏è $desc completado"
  else
    log_warn "‚ö†Ô∏è $desc fall√≥: $*"
  fi
}

run_cmd() {
  local cmd="$1"
  local success_msg="$2"
  local error_msg="$3"
  if eval "$cmd" &>> "$LOG_FILE"; then
    log_success "$success_msg"
  else
    log_warn "$error_msg"
  fi
}

#===============================================================================
# Funciones de instalaci√≥n y eliminaci√≥n de paquetes
#===============================================================================

install_packages() {
  local list_file="$1"
  if [[ ! -f "$list_file" ]]; then
    log_warn "Archivo de lista no encontrado: $list_file"
    return 0
  fi

  log_section "üì¶ Instalaci√≥n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "‚ö†Ô∏è Entrada inv√°lida detectada: '$pkg' ‚Äî omitida"
      continue
    fi

    draw_progress_bar "$count" "$total"

    if [[ "$pkg" == @* ]]; then
      log_info "‚û°Ô∏è Instalando grupo: $pkg"
      if sudo dnf group install "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"; then
        log_success "‚úÖ Grupo instalado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo al instalar grupo: $pkg"
      fi
    elif [[ "$pkg" == *'*'* ]]; then
      log_info "üîç Instalando comod√≠n: $pkg"
      if sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "‚úÖ Wildcard instalado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo wildcard: $pkg"
      fi
    else
      log_info "üì¶ Instalando: $pkg"
      if sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "‚úÖ Instalado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo paquete: $pkg"
      fi
    fi
  done

  return 0
}

remove_packages() {
  local list_file="$1"
  if [[ ! -f "$list_file" ]]; then
    log_warn "Archivo de lista no encontrado: $list_file"
    return 0
  fi

  log_section "üßπ Eliminaci√≥n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "‚ö†Ô∏è Entrada inv√°lida: '$pkg' ‚Äî omitida"
      continue
    fi

    draw_progress_bar "$count" "$total"

    if [[ "$pkg" == @* ]]; then
      log_info "‚ùå Eliminando grupo: $pkg"
      if sudo dnf group remove "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"; then
        log_success "‚úÖ Grupo eliminado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo al eliminar grupo: $pkg"
      fi
    elif [[ "$pkg" == *'*'* ]]; then
      log_info "‚ùå Eliminando comod√≠n: $pkg"
      if sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "‚úÖ Wildcard eliminado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo wildcard: $pkg"
      fi
    else
      log_info "‚ùå Eliminando paquete: $pkg"
      if sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "‚úÖ Eliminado: $pkg"
      else
        log_warn "‚ö†Ô∏è Fallo al eliminar: $pkg"
      fi
    fi
  done

  return 0
}

#===============================================================================
# Instalaci√≥n de aplicaciones adicionales y configuraci√≥n del entorno
#===============================================================================

install_extra_apps() {
  log_section "üì¶ Instalaci√≥n de aplicaciones adicionales del sistema"

  # ‚îÄ‚îÄ‚îÄ 1. Aplicaciones generales desde lista ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ensure_file_exists "$LIST_EXTRA_APPS" || return 1
  log_info "Instalando paquetes desde lista: $(basename "$LIST_EXTRA_APPS")"
  install_packages "$LIST_EXTRA_APPS" || log_warn "‚ö†Ô∏è Algunos paquetes no se instalaron correctamente"

  # ‚îÄ‚îÄ‚îÄ 2. Apps KDE adicionales ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if [[ -f "$LIST_KDE_APPS" ]]; then
    log_info "Instalando apps KDE adicionales: $(basename "$LIST_KDE_APPS")"
    install_packages "$LIST_KDE_APPS" || log_warn "‚ö†Ô∏è Fallo parcial en apps KDE adicionales"
  else
    log_warn "Lista de KDE apps no encontrada: $LIST_KDE_APPS"
  fi

    # ‚îÄ‚îÄ‚îÄ 3. Apps KDE adicionales ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if [[ -f "$LIST_UTILITIES" ]]; then
    log_info "Instalando apps KDE adicionales: $(basename "$LIST_UTILITIES")"
    install_packages "$LIST_UTILITIES" || log_warn "‚ö†Ô∏è Fallo parcial en apps KDE adicionales"
  else
    log_warn "Lista de KDE apps no encontrada: $LIST_UTILITIES"
  fi

  # ‚îÄ‚îÄ‚îÄ 3. Sesi√≥n Xorg (KDE Plasma completa) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if [[ -f "$SCRIPT_DIR/sources/lists/plasma_xorg_full.list" ]]; then
    install_plasma_xorg_full || log_warn "‚ö†Ô∏è Fallo parcial en sesi√≥n Xorg completa"
  else
    log_info "Lista plasma_xorg_full no disponible. Saltando..."
  fi

  # ‚îÄ‚îÄ‚îÄ 4. CLI Tools (modernas, zoxide, navi, bat, fastfetch, etc) ‚îÄ‚îÄ
  if [[ -f "$SCRIPT_DIR/sources/lists/cli_tools.list" ]]; then
    install_cli_tools || log_warn "‚ö†Ô∏è Fallo parcial en CLI Tools"
  else
    log_info "Lista cli_tools.list no disponible. Saltando..."
  fi


  # ‚îÄ‚îÄ‚îÄ 8. Repositorios y utilidades complementarias ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  install_system_utilities
  install_fonts_support
  install_cargo_tools
  install_onlyoffice
  install_flatpak_apps
  configure_vscode
  configure_libvirtd
  configure_sddm
  configure_rtc_clock

  # ‚îÄ‚îÄ‚îÄ 9. Finalizaci√≥n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  log_success "‚úÖ Aplicaciones adicionales instaladas y configuradas correctamente"
}

configure_libvirtd() {
  log_info "Habilitando y configurando libvirtd"

  run_cmd "sudo systemctl start libvirtd" \
    "libvirtd iniciado correctamente" \
    "Error al iniciar libvirtd"

  run_cmd "sudo systemctl enable libvirtd" \
    "libvirtd habilitado para el arranque" \
    "Error al habilitar libvirtd"
}

configure_sddm() {
  log_section "‚öôÔ∏è Configuraci√≥n de SDDM"

  run_cmd "sudo systemctl enable sddm" \
    "SDDM habilitado correctamente" \
    "Error al habilitar SDDM"

  run_cmd "sudo systemctl set-default graphical.target" \
    "Target gr√°fico configurado correctamente" \
    "Error al configurar target gr√°fico"

  configure_sddm_numlock
  configure_sddm_hide_users
}

configure_sddm_numlock() {
  log_info "Activando NumLock en SDDM"
  local config="/etc/sddm.conf"

  if [[ -f "$config" ]]; then
    sudo sed -i '/^\[General\]/,/^\[/{s/^Numlock=.*/Numlock=on/; t; aNumlock=on}' "$config"
  else
    echo -e "[General]\nNumlock=on" | sudo tee "$config" > /dev/null
  fi

  run_cmd "sudo systemctl daemon-reexec" \
    "SDDM recargado correctamente" \
    "Fallo al recargar SDDM (puede requerir reinicio)"
}

configure_sddm_hide_users() {
  local conf_file="/etc/sddm.conf"
  local username="libvirt-qemu"

  log_info "Ocultando usuario '$username' en pantalla de SDDM"

  if [[ -f "$conf_file" ]]; then
    if ! grep -q "^\[Users\]" "$conf_file"; then
      echo -e "\n[Users]\nHideUsers=$username" | sudo tee -a "$conf_file" > /dev/null
    elif ! grep -q "^HideUsers=" "$conf_file"; then
      sudo sed -i "/^\[Users\]/a HideUsers=$username" "$conf_file"
    else
      sudo sed -i "s/^HideUsers=.*/HideUsers=$username/" "$conf_file"
    fi
  else
    echo -e "[Users]\nHideUsers=$username" | sudo tee "$conf_file" > /dev/null
  fi

  log_success "Usuario '$username' oculto en SDDM"
}

configure_rtc_clock() {
  log_info "Configurando RTC en hora local"

  if timedatectl set-local-rtc 1 &>> "$LOG_FILE"; then
    log_success "RTC configurado en hora local"
  else
    log_warn "No se pudo configurar el RTC"
  fi
}

install_onlyoffice() {
  log_info "Instalando OnlyOffice Desktop Editors"

  run_cmd "sudo dnf install -y onlyoffice-desktopeditors" \
    "OnlyOffice instalado correctamente" \
    "Error al instalar OnlyOffice"
}

install_flatpak_apps() {
  log_section "üì¶ Instalando aplicaciones Flatpak desde Flathub"

  local flatpak_apps=(
    "com.github.dail8859.NotepadNext"
    "org.localsend.localsend_app"
    "org.strawberrymusicplayer.strawberry"
    "org.nomacs.ImageLounge"
    "com.github.vkohaupt.vokoscreenNG"
    "tv.kodi.Kodi"
    "org.appimage.AppImageLauncher"
    "com.github.manisandro.gImageReader"
  )

  if ! command -v flatpak &>/dev/null; then
    log_info "Flatpak no est√° instalado. Procediendo a instalar..."
    run_cmd "sudo dnf install -y flatpak" \
      "Flatpak instalado correctamente" \
      "Fallo al instalar Flatpak"
  fi

  run_cmd "flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo" \
    "Repositorio Flathub a√±adido correctamente" \
    "Fallo al a√±adir Flathub"

  for app in "${flatpak_apps[@]}"; do
    log_info "Instalando Flatpak: $app"
    if ! flatpak install -y --noninteractive flathub "$app" &>> "$LOG_FILE"; then
      log_warn "Fallo al instalar $app desde Flatpak"
    else
      log_success "$app instalado correctamente"
    fi
  done
}

configure_vscode() {
  log_section "üß© Configurando Visual Studio Code"

  if ! command -v code &>/dev/null; then
    log_info "VSCode no encontrado. Intentando instalar..."
    run_cmd "sudo dnf install -y code" \
      "Visual Studio Code instalado" \
      "Fallo al instalar Visual Studio Code"
  fi

  local vscode_config="$HOME/.config/Code/User"
  mkdir -p "$vscode_config"

  cat > "$vscode_config/settings.json" <<EOF
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "prettier.singleQuote": true,
  "prettier.trailingComma": "all",
  "prettier.jsxSingleQuote": true,
  "prettier.printWidth": 80,
  "editor.fontFamily": "JetBrainsMono Nerd Font,Menlo,Monaco,Courier New,monospace,Noto Color Emoji",
  "editor.fontLigatures": true,
  "editor.fontSize": 14,
  "editor.lineHeight": 24,
  "editor.fontWeight": "400",
  "workbench.colorTheme": "One Monokai"
}
EOF

  log_success "Configuraci√≥n VSCode generada correctamente"

  local extensions=(
    "azemoh.one-monokai"
    "NarasimaPandiyan.jetbrainsmono"
  )

  for ext in "${extensions[@]}"; do
    log_info "Instalando extensi√≥n: $ext"
    if ! code --install-extension "$ext" &>> "$LOG_FILE"; then
      log_warn "No se pudo instalar la extensi√≥n: $ext"
    else
      log_success "Extensi√≥n instalada: $ext"
    fi
  done
}

configure_libvirtd() {
  log_info "üîß Configurando libvirtd"

  run_cmd "sudo systemctl start libvirtd" \
    "libvirtd iniciado correctamente" \
    "Error al iniciar libvirtd"

  run_cmd "sudo systemctl enable libvirtd" \
    "libvirtd habilitado para el arranque" \
    "Error al habilitar libvirtd"
}

# ‚îÄ‚îÄ‚îÄ Shell de ayuda ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

run_cmd() {
  local cmd="$1"
  local msg_ok="$2"
  local msg_err="$3"

  if eval "$cmd" &>> "$LOG_FILE"; then
    log_success "$msg_ok"
  else
    log_warn "$msg_err"
  fi
}

check_dependencies() {
  log_section "üîç Verificando dependencias del sistema"

  local dependencies=(dnf sudo curl wget flatpak git jq unzip tar lsb_release)
  local missing=()

  for cmd in "${dependencies[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      missing+=("$cmd")
      log_warn "Dependencia ausente: $cmd"
    fi
  done

  if (( ${#missing[@]} > 0 )); then
    log_info "Instalando dependencias faltantes: ${missing[*]}"
    sudo dnf install -y "${missing[@]}"
  else
    log_success "‚úÖ Todas las dependencias est√°n satisfechas"
  fi
}

validate_command() {
    local cmd="$1"
    if ! command -v "$cmd" &>/dev/null; then
        log_error "El comando '$cmd' no est√° disponible en el sistema"
        return 1
    fi
}


add_repositories() {
  log_section "‚ûï Habilitando repositorios de terceros (Brave, RPM Fusion, VSCode, COPR)"

  validate_command dnf || return 1
  validate_command rpm || return 1

  # Brave Browser
  if ! sudo dnf repolist | grep -q brave-browser; then
    try_cmd "Agregar repo Brave" sudo dnf config-manager --add-repo https://brave-browser-rpm-release.s3.brave.com/brave-browser.repo
    try_cmd "Importar clave Brave" sudo rpm --import https://brave-browser-rpm-release.s3.brave.com/brave-core.asc
    log_success "Repositorio Brave a√±adido"
  else
    log_info "Repositorio Brave ya est√° habilitado"
  fi

  # RPM Fusion
  if ! rpm -q rpmfusion-free-release &>/dev/null; then
    try_cmd "Instalar RPM Fusion" sudo dnf install -y \
      https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm \
      https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm
    log_success "RPM Fusion habilitado"
  else
    log_info "RPM Fusion ya est√° instalado"
  fi

  # Microsoft VSCode
  if [[ ! -f /etc/yum.repos.d/vscode.repo ]]; then
    try_cmd "Importar clave GPG Microsoft" sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
    try_cmd "Crear repo VSCode" sudo tee /etc/yum.repos.d/vscode.repo > /dev/null <<EOF
[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc
EOF
    log_success "Repositorio VSCode habilitado"
  else
    log_info "Repositorio VSCode ya est√° presente"
  fi

  # COPR Repos (opcional, si hay archivo copr.list)
  local copr_file="./sources/lists/copr.list"
  if [[ -f "$copr_file" ]]; then
    enable_copr_repos "$copr_file"
  else
    log_warn "No se encontr√≥ archivo COPR ($copr_file), se omite habilitaci√≥n"
  fi

  # Actualizar cach√©
  try_cmd "Actualizar cach√© de repositorios" sudo dnf makecache
}


configure_hardware() {
  # ‚îÄ‚îÄ‚îÄ Soporte gr√°fico (GPU) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  log_section "Detectando y configurando GPU"

  mapfile -t gpu_list < <(lspci | grep -iE "VGA|3D controller")
  for gpu_entry in "${gpu_list[@]}"; do
    log_info "GPU detectada: $gpu_entry"

    if echo "$gpu_entry" | grep -qi "Intel"; then
      log_section "Configurando GPU Intel..."
      run_cmd "sudo dnf install -y intel-media-driver vdpau-driver-all libva-utils" \
        "Drivers de Intel instalados" "Error al instalar drivers Intel"

    elif echo "$gpu_entry" | grep -qi "AMD"; then
      log_section "Configurando GPU AMD..."
      run_cmd "sudo dnf install -y akmod-amdgpu mesa-va-drivers-freeworld mesa-vdpau-drivers-freeworld vdpau-driver-all libva-utils" \
        "Drivers de AMD instalados" "Error al instalar drivers AMD"
      run_cmd "sudo dnf swap -y mesa-va-drivers mesa-va-drivers-freeworld" \
        "mesa-va-drivers actualizado" "Error al reemplazar mesa-va-drivers"
      run_cmd "sudo dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld" \
        "mesa-vdpau-drivers actualizado" "Error al reemplazar mesa-vdpau-drivers"

    elif echo "$gpu_entry" | grep -qi "NVIDIA"; then
      log_section "Configurando GPU NVIDIA..."
      run_cmd "sudo dnf install -y akmod-nvidia nvidia-driver nvidia-settings nvidia-vaapi-driver vdpau-driver-all libva-utils" \
        "Drivers de NVIDIA instalados" "Error al instalar drivers NVIDIA"
      run_cmd "sudo grubby --update-kernel=ALL --args='nvidia-drm.modeset=1'" \
        "Kernel configurado para NVIDIA (modeset)" "Error al configurar kernel para NVIDIA"
      log_warn "Es probable que necesite reiniciar para aplicar configuraci√≥n NVIDIA."

    else
      log_warn "Fabricante de GPU no reconocido: $gpu_entry. Omitiendo configuraci√≥n."
    fi
  done

  # Validar herramientas de aceleraci√≥n
  log_section "Verificando APIs de aceleraci√≥n de video..."
  try_cmd "Instalar libva-utils" sudo dnf install -y libva-utils
  try_cmd "Instalar vdpauinfo" sudo dnf install -y vdpauinfo

  for api in vaapi vdpau; do
    if command -v "${api}-info" &>/dev/null; then
      log_success "API $api disponible"
    else
      log_warn "API $api no encontrada. Puede afectar reproducci√≥n de video."
    fi
  done

  # ‚îÄ‚îÄ‚îÄ Soporte para CPU ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  log_section "Configurando soporte para CPU"

  local hypervisor
  hypervisor=$(systemd-detect-virt)
  if [[ "$hypervisor" != "none" ]]; then
    log_info "Sistema virtual detectado ($hypervisor). Omitiendo instalaci√≥n de microc√≥digos."
    return 0
  fi

  local cpu_name
  cpu_name=$(lscpu | grep -Ei 'Model name|Nombre del modelo' | head -n 1)
  log_info "CPU detectada: ${cpu_name:-Desconocida}"

  if echo "$cpu_name" | grep -qi "intel"; then
    log_section "Procesador Intel detectado. Instalando microc√≥digo..."
    run_cmd "sudo dnf install -y --enablerepo=rpmfusion-nonfree microcode_ctl" \
      "Microc√≥digo de Intel instalado" "Error al instalar microc√≥digo de Intel"

  elif echo "$cpu_name" | grep -qi "amd"; then
    log_section "Procesador AMD detectado. Instalando microc√≥digo..."
    run_cmd "sudo dnf install -y --enablerepo=rpmfusion-nonfree amd-ucode" \
      "Microc√≥digo de AMD instalado" "Error al instalar microc√≥digo de AMD"
    log_info "Regenerando initramfs para cargar el microc√≥digo AMD"
    run_cmd "sudo dracut -f" \
      "initramfs regenerado correctamente" "Error al regenerar initramfs"

  else
    log_warn "No se pudo identificar el fabricante del procesador. Omitiendo instalaci√≥n de microc√≥digos."
  fi

  run_cmd "sudo dnf install -y cpuid cpu-x" \
    "Herramientas de diagn√≥stico CPU instaladas" "Error al instalar herramientas de diagn√≥stico"

  log_info "Verificando microc√≥digo en kernel..."
  if dmesg | grep -qi microcode; then
    dmesg | grep -i microcode | tee -a "$LOG_FILE"
    log_success "Microc√≥digo aplicado detectado en kernel"
  else
    log_warn "No se detect√≥ microc√≥digo activo en el kernel (dmesg vac√≠o)"
  fi
}

install_multimedia() {
  log_section "üéµ Instalaci√≥n del stack multimedia (codecs, reproductores, AV)"

  # Verificaci√≥n de archivos requeridos
  ensure_file_exists "$LIST_MULTIMEDIA" || {
    log_error "Lista de paquetes multimedia no encontrada: $LIST_MULTIMEDIA"
    return 1
  }

  ensure_file_exists "$LIST_CODECS" || {
    log_error "Lista de codecs no encontrada: $LIST_CODECS"
    return 1
  }

  # Actualizar grupo multimedia base
  try_cmd "Actualizando grupo sound-and-video" \
    sudo dnf groupupdate -y sound-and-video

  # Instalar paquetes multimedia generales
  install_packages "$LIST_MULTIMEDIA" || log_warn "‚ö†Ô∏è Algunos paquetes multimedia fallaron"

  # Instalar codecs adicionales
  install_packages "$LIST_CODECS" || log_warn "‚ö†Ô∏è Algunos codecs fallaron durante la instalaci√≥n"

  log_success "Stack multimedia y codecs instalados correctamente."
}


configure_konsole() {
  log_section "üé® Configuraci√≥n de Konsole (terminal KDE)"

  local konsole_dir="$HOME/.local/share/konsole"
  local config_dir="$HOME/.config"
  mkdir -p "$konsole_dir"

  cat > "$konsole_dir/Initium.profile" <<EOF
[General]
Name=Initium
Command=/bin/zsh
Icon=utilities-terminal
EOF

  cat > "$config_dir/konsolerc" <<EOF
[Desktop Entry]
DefaultProfile=Initium.profile
EOF

  log_success "Perfil de Konsole personalizado creado"
}

system_cleanup() {
  log_section "üßΩ Limpieza final del sistema"

  run_cmd "sudo dnf autoremove -y" "Dependencias hu√©rfanas eliminadas" "Fallo al ejecutar autoremove"
  run_cmd "sudo dnf clean all" "Cache de DNF limpiada" "Fallo al limpiar DNF"
  run_cmd "flatpak uninstall --unused -y" "Flatpaks no usados eliminados" "Fallo al limpiar Flatpaks"
}

install_plasma_xorg_full() {
  log_section "üèûÔ∏è Instalando KDE Plasma (sesi√≥n Xorg completa)"
  local list="${SCRIPT_DIR}/sources/lists/plasma_xorg_full.list"
  if [[ -f "$list" ]]; then
    install_packages "$list"
  else
    log_warn "plasma_xorg_full.list no encontrado"
  fi
}

install_cli_tools() {
  log_section "üß∞ Instalaci√≥n de CLI Tools modernas"
  local cli_list="${SCRIPT_DIR}/sources/lists/cli_tools.list"
  if [[ ! -f "$cli_list" ]]; then
    log_error "Archivo de lista no encontrado: $cli_list"
    return 1
  fi
  install_packages "$cli_list" || log_warn "Algunas CLI tools no se pudieron instalar completamente"
  log_success "‚úÖ CLI Tools instaladas correctamente"
  configure_cli_tools
}

install_fonts_support() {
  log_info "Instalando fuentes base, JetBrainsMono, Ubuntu Nerd Font y Poppins..."

  local fonts_base=(
    google-noto-sans-fonts
    google-noto-serif-fonts
    google-noto-mono-fonts
    google-roboto-fonts
    curl
    cabextract
    xorg-x11-font-utils
    fontconfig
    freetype-freeworld
    unzip
  )

  for pkg in "${fonts_base[@]}"; do
    try_cmd "Instalaci√≥n fuente base: $pkg" sudo dnf install -y "$pkg"
  done

  local font_dir="$HOME/.local/share/fonts"
  mkdir -p "$font_dir"

  # JetBrainsMono Nerd Font
  local jb_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/JetBrainsMono.zip"
  local jb_zip="/tmp/JetBrainsMono.zip"

  log_info "Descargando JetBrainsMono Nerd Font..."
  try_cmd "Descarga JetBrainsMono.zip" curl -Ls -o "$jb_zip" "$jb_url"
  try_cmd "Descomprimir JetBrainsMono" unzip -o "$jb_zip" -d "$font_dir"
  rm -f "$jb_zip"

  # Ubuntu Nerd Font
  local ub_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Ubuntu.zip"
  local ub_zip="/tmp/UbuntuNF.zip"

  log_info "Descargando Ubuntu Nerd Font..."
  try_cmd "Descarga Ubuntu.zip" curl -Ls -o "$ub_zip" "$ub_url"
  try_cmd "Descomprimir UbuntuNF" unzip -o "$ub_zip" -d "$font_dir"
  rm -f "$ub_zip"

  # Poppins desde Google Fonts
  local poppins_url="https://github.com/google/fonts/raw/main/ofl/poppins/Poppins%5Bwght%5D.ttf"
  log_info "Descargando fuente Poppins..."
  try_cmd "Descarga Poppins.ttf" curl -Ls -o "$font_dir/Poppins.ttf" "$poppins_url"

  # Regenerar cach√©
  log_info "Regenerando cach√© de fuentes..."
  try_cmd "fc-cache" fc-cache -fv "$font_dir"

  log_success "Fuentes instaladas correctamente: Noto, Roboto, JetBrainsMono NF, Ubuntu NF, Poppins"
}


configure_cli_tools() {
  log_section "‚öôÔ∏è Configuraci√≥n de CLI Tools"
  local dotfiles_dir="${SCRIPT_DIR}/../../dotfiles"
  mkdir -p ~/.config

  if [[ -f "$dotfiles_dir/.zshrc" ]]; then
    cp -f "$dotfiles_dir/.zshrc" ~/.zshrc
    log_success ".zshrc personalizado aplicado"
  fi

  if command -v fastfetch &>/dev/null && [[ -f "$dotfiles_dir/fastfetch_config.jsonc" ]]; then
    mkdir -p ~/.config/fastfetch
    cp -f "$dotfiles_dir/fastfetch_config.jsonc" ~/.config/fastfetch/config.jsonc
    log_success "Configuraci√≥n de fastfetch aplicada"
  fi

  if [[ -f "$dotfiles_dir/topgrade.toml" ]]; then
    mkdir -p ~/.config
    cp -f "$dotfiles_dir/topgrade.toml" ~/.config/topgrade.toml
    log_success "Configuraci√≥n de topgrade aplicada"
  fi

  if command -v bat &>/dev/null || command -v batcat &>/dev/null; then
    mkdir -p ~/.config/bat
    echo '--theme="TwoDark"' > ~/.config/bat/config
    log_success "Configuraci√≥n de bat aplicada"
  fi

  if command -v zoxide &>/dev/null; then
    grep -q 'zoxide init' ~/.zshrc || echo 'eval "$(zoxide init zsh)"' >> ~/.zshrc
    log_success "zoxide integrado en .zshrc"
  fi

  if command -v navi &>/dev/null; then
    mkdir -p ~/.config/navi
    if [[ ! -d ~/.config/navi/cheats ]]; then
      git clone https://github.com/denisidoro/cheat.sh.git ~/.config/navi/cheats &&
      log_success "Cheatsheets de navi instalados"
    else
      log_info "Cheatsheets de navi ya presentes"
    fi
    grep -q 'navi widget zsh' ~/.zshrc || echo 'eval "$(navi widget zsh)"' >> ~/.zshrc
  fi

  ensure_zsh_as_default

  if [[ -f "$dotfiles_dir/.nanorc" ]]; then
    cp -f "$dotfiles_dir/.nanorc" ~/.nanorc
    log_success ".nanorc personalizado aplicado"
  fi

  log_success "üéØ Configuraci√≥n personalizada de CLI Tools completada"
}
