#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
trap 'echo "‚ñ† Error en la l√≠nea $LINENO"; exit 1' ERR

#===============================================================================
# Archivo: functions2_pilares_fedora_refactor.sh
# Proyecto: Fedora Post-Install (KDE)
# Descripci√≥n: Funciones reutilizables y modulares para postinstalaci√≥n
# Autor: Gabriel Oma√±a / Initium
# Licencia: MIT
#===============================================================================

# ‚îÄ‚îÄ‚îÄ Protecci√≥n contra ejecuci√≥n directa ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "[ERROR] Este archivo es un m√≥dulo de funciones y no debe ejecutarse directamente."
  echo "        Por favor, incl√∫yelo con: source ${BASH_SOURCE[0]}"
  exit 1
fi

# ‚îÄ‚îÄ‚îÄ Variables de entorno y rutas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$(realpath "${BASH_SOURCE[0]}")")" && pwd)}"
LISTS_DIR="${SCRIPT_DIR}/sources/lists"
LOG_DIR="$HOME/fedora_logs"
LOG_FILE="${LOG_DIR}/pkg_manager.log"

LIST_KDE_PLASMA="${LISTS_DIR}/kde_plasma.list"
LIST_KDE_APPS="${LISTS_DIR}/kde_plasma_apps.list"
LIST_KDE_BLOATWARE="${LISTS_DIR}/kde_bloatware.list"
LIST_MULTIMEDIA="${LISTS_DIR}/multimedia.list"
LIST_CODECS="${LISTS_DIR}/codecs.list"
LIST_UTILITIES="${LISTS_DIR}/utilities.list"
LIST_EXTRA_APPS="${LISTS_DIR}/extra_apps.list"
LIST_XORG_WORKSPACE="${LISTS_DIR}/plasma_xorg_full.list"

REQUIRED_LISTS=(
  "$LIST_KDE_PLASMA"
  "$LIST_KDE_APPS"
  "$LIST_KDE_BLOATWARE"
  "$LIST_MULTIMEDIA"
  "$LIST_CODECS"
  "$LIST_UTILITIES"
  "$LIST_EXTRA_APPS"
  "$LIST_XORG_WORKSPACE"
)

# ‚îÄ‚îÄ‚îÄ Validaci√≥n de listas necesarias ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
for list_file in "${REQUIRED_LISTS[@]}"; do
  [[ -f "$list_file" ]] || {
    echo "[ERROR] Lista no encontrada: $list_file"
    exit 1
  }
done

# ‚îÄ‚îÄ‚îÄ Configuraci√≥n de logging persistente ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
mkdir -p "$LOG_DIR"
touch "$LOG_FILE"

# ‚îÄ‚îÄ‚îÄ Colores ANSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if [[ -t 1 ]]; then
  RED="\033[0;31m"
  GREEN="\033[0;32m"
  YELLOW="\033[1;33m"
  BLUE="\033[1;34m"
  BOLD="\033[1m"
  NC="\033[0m"
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; BOLD=""; NC=""
fi

# ‚îÄ‚îÄ‚îÄ Funciones de logging ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
log_info()    { echo -e "${BLUE}[INFO]    $*${NC}"; }
log_warn()    { echo -e "${YELLOW}[WARN]    $*${NC}"; }
log_error()   { echo -e "${RED}[ERROR]   $*${NC}" >&2; ((ERROR_COUNT++)) || true; }
log_success() { echo -e "${GREEN}[OK]      $*${NC}"; }
log_section() {
  local title="$1"
  local clean_title="${title//[$'\t\r\n']}"
  local visual_width=${#clean_title}
  local padding=4
  local total_width=$((visual_width + padding))
  local border
  border=$(printf '‚îÄ%.0s' $(seq 1 "$total_width"))
  echo -e "\n${BLUE}‚îå$border‚îê${NC}"
  echo -e "${BLUE}‚îÇ  ${BOLD}${title}${NC}${BLUE}  ‚îÇ${NC}"
  echo -e "${BLUE}‚îî$border‚îò${NC}\n"
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECTION] $title" >> "$LOG_FILE"
}
#===============================================================================
# Funciones utilitarias generales
#===============================================================================

check_command() {
  command -v "$1" &>/dev/null || {
    log_error "Comando requerido no disponible: $1"
    return 1
  }
}

ensure_file_exists() {
  local file="$1"
  [[ -f "$file" ]] || {
    log_error "Archivo no encontrado: $file"
    return 1
  }
}

run_sudo() {
  if ! sudo -n true 2>/dev/null; then
    log_warn "Se requiere autenticaci√≥n sudo..."
    sudo -v || {
      log_error "No se pudo elevar a sudo. Abortando."
      exit 1
    }
  fi
}

is_root() {
  [[ "$EUID" -eq 0 ]]
}

draw_progress_bar() {
  local current=$1
  local total=$2
  local width=40
  local percent=$(( current * 100 / total ))
  local filled=$(( current * width / total ))
  local empty=$(( width - filled ))
  local progress_bar
  progress_bar=$(printf "%-${filled}s" "#" | tr ' ' '#')
  progress_bar+=$(printf "%-${empty}s" "-" | tr ' ' '-')
  printf "\r[%s] %3d%% (%d/%d)" "$progress_bar" "$percent" "$current" "$total"
  [[ "$current" -eq "$total" ]] && echo ""
}

try_cmd() {
  local desc="$1"; shift
  if "$@"; then
    log_success "$desc completado"
  else
    log_warn "$desc fall√≥: $*"
    return 1
  fi
}
#===============================================================================
# Aplicaci√≥n de dotfiles
#===============================================================================
load_dotfiles() {
  local df_dir="$SCRIPT_DIR/dotfiles"
  log_section "Aplicando dotfiles..."

  # Dotfiles b√°sicos
  [[ -f "$df_dir/.zshrc" ]]        && cp "$df_dir/.zshrc" ~/.zshrc           && log_success "Copiado .zshrc"
  [[ -f "$df_dir/.nanorc" ]]       && cp "$df_dir/.nanorc" ~/.nanorc         && log_success "Copiado .nanorc"
  [[ -f "$df_dir/.aliases" ]]      && cp "$df_dir/.aliases" ~/.aliases       && log_success "Copiado .aliases"
  [[ -f "$df_dir/.exports" ]]      && cp "$df_dir/.exports" ~/.exports       && log_success "Copiado .exports"

  # Neofetch
  if [[ -f "$df_dir/neofetch.conf" ]]; then
    mkdir -p ~/.config/neofetch
    cp "$df_dir/neofetch.conf" ~/.config/neofetch/config.conf
    log_success "Neofetch configurado"
  fi

  # Starship
  if [[ -f "$df_dir/starship.toml" ]]; then
    mkdir -p ~/.config
    cp "$df_dir/starship.toml" ~/.config/starship.toml
    log_success "Starship configurado"
  fi

  # Topgrade
  if [[ -f "$df_dir/topgrade.toml" ]]; then
    mkdir -p ~/.config
    cp "$df_dir/topgrade.toml" ~/.config/topgrade.toml
    log_success "Topgrade configurado"
  fi

  # Fastfetch
  if [[ -f "$df_dir/fastfetch_config.jsonc" ]]; then
    mkdir -p ~/.config/fastfetch
    cp "$df_dir/fastfetch_config.jsonc" ~/.config/fastfetch/config.jsonc
    log_success "Fastfetch configurado"
  fi

  # Konsole (si aplica)
  if [[ -f "$df_dir/konsole.profile" || -f "$df_dir/konsolerc" ]]; then
    mkdir -p ~/.local/share/konsole ~/.config
    [[ -f "$df_dir/konsole.profile" ]] && cp "$df_dir/konsole.profile" ~/.local/share/konsole/Default.profile && log_success "Konsole profile aplicado"
    [[ -f "$df_dir/konsolerc" ]]       && cp "$df_dir/konsolerc" ~/.config/konsolerc && log_success "Konsole rc aplicado"
  fi

  log_info "Dotfiles aplicados correctamente"
}


#===============================================================================
# Instalaci√≥n de paquetes desde listas
#===============================================================================
install_packages() {
  local list_file="$1"
  ensure_file_exists "$list_file" || return 1

  log_section "üì¶ Instalaci√≥n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    draw_progress_bar "$count" "$total"

    # Validar entrada sospechosa
    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "Entrada inv√°lida detectada: '$pkg' ‚Äî omitida"
      continue
    fi

    if [[ "$pkg" == @* ]]; then
      log_info "‚û°Ô∏è Instalando grupo: $pkg"
      try_cmd "Grupo $pkg" sudo dnf group install "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"
    elif [[ "$pkg" == *'*'* ]]; then
      log_info "üîç Instalando comod√≠n: $pkg"
      try_cmd "Wildcard $pkg" sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
    else
      log_info "üì¶ Instalando: $pkg"
      try_cmd "Paquete $pkg" sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
    fi
  done
}

#===============================================================================
# Eliminaci√≥n de paquetes desde listas
#===============================================================================
remove_packages() {
  local list_file="$1"
  ensure_file_exists "$list_file" || return 1

  log_section "üßπ Eliminaci√≥n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --setopt=clean_requirements_on_remove=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    draw_progress_bar "$count" "$total"

    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "Entrada inv√°lida detectada: '$pkg' ‚Äî omitida"
      continue
    fi

    log_info "üóëÔ∏è Eliminando: $pkg"
    try_cmd "Eliminaci√≥n $pkg" sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
  done
}

install_packages_refactor() {
  local list_file="$1"
  ensure_file_exists "$list_file" || return 1

  log_section "üì¶ Instalaci√≥n desde lista: $(basename "$list_file")"
  mapfile -t raw_lines < "$list_file"

  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    draw_progress_bar "$count" "$total"

    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "‚ö†Ô∏è Entrada inv√°lida detectada: '$pkg' ‚Äî omitida"
      continue
    fi

    case "$pkg" in
      @*)
        log_info "‚û°Ô∏è Instalando grupo: $pkg"
        try_cmd "Grupo $pkg" sudo dnf group install "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"
        ;;
      *'*'*)
        log_info "üîç Instalando comod√≠n: $pkg"
        try_cmd "Wildcard $pkg" sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
        ;;
      *)
        log_info "üì¶ Instalando: $pkg"
        try_cmd "Paquete $pkg" sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
        ;;
    esac
  done
}

remove_packages_refactor() {
  local list_file="$1"
  ensure_file_exists "$list_file" || return 1

  log_section "üßπ Eliminaci√≥n desde lista: $(basename "$list_file")"
  mapfile -t raw_lines < "$list_file"

  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))
    draw_progress_bar "$count" "$total"

    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "‚ö†Ô∏è Entrada inv√°lida: '$pkg' ‚Äî omitida"
      continue
    fi

    case "$pkg" in
      @*)
        log_info "‚ùå Eliminando grupo: $pkg"
        try_cmd "Grupo $pkg" sudo dnf group remove "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"
        ;;
      *'*'*)
        log_info "‚ùå Eliminando comod√≠n: $pkg"
        try_cmd "Wildcard $pkg" sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
        ;;
      *)
        log_info "‚ùå Eliminando paquete: $pkg"
        try_cmd "Paquete $pkg" sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"
        ;;
    esac
  done
}

install_konsole_and_dotfiles() {
  log_section "üé® Instalaci√≥n de Konsole y dotfiles personalizados"

  local config_src="${SCRIPT_DIR}/../../dotfiles"
  local fastfetch_dir="${SCRIPT_DIR}/../../fastfetch"

  try_cmd "Eliminar instalaci√≥n previa de Fastfetch" sudo rm -rf "$fastfetch_dir"
  try_cmd "Clonar repositorio Fastfetch" sudo git clone https://github.com/fastfetch-cli/fastfetch.git "$fastfetch_dir"
  try_cmd "Compilar Fastfetch" bash -c "cd $fastfetch_dir && mkdir -p build && cd build && cmake .. && cmake --build ."
  try_cmd "Instalar binarios Fastfetch" sudo cp "$fastfetch_dir/build/"{fastfetch,flashfetch} /usr/bin/
  try_cmd "Generar configuraci√≥n Fastfetch" fastfetch --gen-config-force

  [[ -f "$config_src/fastfetch_config.jsonc" ]] &&
    cp -f "$config_src/fastfetch_config.jsonc" ~/.config/fastfetch/config.jsonc &&
    log_success "Configuraci√≥n personalizada de Fastfetch aplicada" ||
    log_warn "Archivo fastfetch_config.jsonc no encontrado"

  try_cmd "Descargar temas Konsole" wget -q https://github.com/gabrielomana/color_schemes/raw/main/konsole.zip -O /tmp/konsole.zip
  try_cmd "Instalar temas Konsole" unzip -o /tmp/konsole.zip -d /tmp/ && sudo mkdir -p /usr/share/konsole && sudo cp -rf /tmp/konsole/* /usr/share/konsole/
  try_cmd "Eliminar temporales de temas" sudo rm -rf /tmp/konsole /tmp/konsole.zip

  # Dotfiles varios
  cp -f "$config_src/.nanorc" ~/.nanorc && log_success ".nanorc aplicado"
  cp -f "$config_src/topgrade.toml" ~/.config/topgrade.toml && log_success "topgrade.toml aplicado"
  cp -f "$config_src/konsolerc" ~/.config/konsolerc && log_success "konsolerc aplicado"
  mkdir -p ~/.local/share/konsole
  cp -f "$config_src/konsole.profile" ~/.local/share/konsole/ && log_success "konsole.profile aplicado"
}

configure_multimedia_and_gpu() {
  log_section "üéûÔ∏è Configuraci√≥n de c√≥decs multimedia y soporte GPU"

  # Paquetes multimedia b√°sicos
  run_cmd "sudo dnf install -y --allowerasing --skip-broken \
ffmpeg-libs gstreamer1-plugin-mpg123 gstreamer1-plugin-openh264 \
gstreamer1-plugins-bad-free gstreamer1-plugins-bad-freeworld \
gstreamer1-plugins-base gstreamer1-plugins-good \
gstreamer1-plugins-ugly libva libva-utils" \
"Paquetes multimedia instalados" "Fallo al instalar multimedia"

  # Detectar GPU
  mapfile -t gpu_list < <(lspci | grep -iE "VGA|3D controller")
  for gpu_entry in "${gpu_list[@]}"; do
    log_info "GPU detectada: $gpu_entry"

    if echo "$gpu_entry" | grep -qi "Intel"; then
      run_cmd "sudo dnf install -y intel-media-driver vdpau-driver-all libva-utils" \
      "Drivers Intel instalados" "Error Intel"
    elif echo "$gpu_entry" | grep -qi "AMD"; then
      run_cmd "sudo dnf install -y akmod-amdgpu mesa-va-drivers-freeworld mesa-vdpau-drivers-freeworld vdpau-driver-all libva-utils" \
      "Drivers AMD instalados" "Error AMD"
      run_cmd "sudo dnf swap -y mesa-va-drivers mesa-va-drivers-freeworld" \
      "mesa-va-drivers actualizado" "Error mesa-va"
      run_cmd "sudo dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld" \
      "mesa-vdpau-drivers actualizado" "Error mesa-vdpau"
    elif echo "$gpu_entry" | grep -qi "NVIDIA"; then
      run_cmd "sudo dnf install -y akmod-nvidia nvidia-driver nvidia-settings nvidia-vaapi-driver vdpau-driver-all libva-utils" \
      "Drivers NVIDIA instalados" "Error NVIDIA"
      run_cmd "sudo grubby --update-kernel=ALL --args='nvidia-drm.modeset=1'" \
      "Kernel NVIDIA configurado" "Error modeset"
      log_warn "Es probable que necesite reiniciar para aplicar cambios NVIDIA"
    else
      log_warn "Fabricante GPU no reconocido: $gpu_entry"
    fi
  done

  # Diagn√≥stico de APIs
  for tool in vaapi-info vdpauinfo; do
    if ! command -v "$tool" &>/dev/null; then
      run_cmd "sudo dnf install -y $tool" "$tool instalado" "Error $tool"
    fi
  done

  for api in vaapi vdpau; do
    if command -v "${api}-info" &>/dev/null; then
      log_success "API $api disponible"
    else
      log_warn "API $api no encontrada"
    fi
  done
}

setup_cpu_microcode() {
  log_section "üß† Configuraci√≥n de microc√≥digo de CPU"

  local virt
  virt=$(systemd-detect-virt)
  if [[ "$virt" != "none" ]]; then
    log_info "Entorno virtual detectado ($virt), se omite instalaci√≥n de microc√≥digos"
    return 0
  fi

  local cpu_name
  cpu_name=$(lscpu | grep -Ei 'Model name|Nombre del modelo' | head -n1)
  log_info "CPU detectada: ${cpu_name:-Desconocida}"

  if echo "$cpu_name" | grep -qi "intel"; then
    run_cmd "sudo dnf install -y microcode_ctl --enablerepo=rpmfusion-nonfree" "Microc√≥digo Intel instalado" "Error microcode Intel"
  elif echo "$cpu_name" | grep -qi "amd"; then
    run_cmd "sudo dnf install -y amd-ucode --enablerepo=rpmfusion-nonfree" "Microc√≥digo AMD instalado" "Error microcode AMD"
    run_cmd "sudo dracut -f" "initramfs regenerado" "Error initramfs"
  else
    log_warn "Fabricante de CPU no identificado. Se omite microc√≥digo"
  fi

  run_cmd "sudo dnf install -y cpuid cpu-x" "Herramientas CPU instaladas" "Error herramientas CPU"
}

clean_kde_bloatware() {
  local list_file="${SCRIPT_DIR}/sources/lists/kde_bloatware.list"
  ensure_file_exists "$list_file" || return 1

  log_section "üßΩ Eliminando bloatware de KDE"
  local removed_log="$LOG_DIR/bloatware_removed_$(date +%F_%H-%M-%S).log"
  local pkgs_to_remove=()

  while IFS= read -r pkg || [[ -n "$pkg" ]]; do
    pkg="${pkg%%#*}"; pkg="${pkg//[[:space:]]/}"
    [[ -z "$pkg" ]] && continue
    rpm -q "$pkg" &>/dev/null && pkgs_to_remove+=("$pkg") || log_info "No instalado: $pkg"
  done < "$list_file"

  if [[ ${#pkgs_to_remove[@]} -eq 0 ]]; then
    log_info "No hay bloatware para eliminar"
    return 0
  fi

  printf "%s\n" "${pkgs_to_remove[@]}" > "$removed_log"
  log_info "Lista de paquetes eliminados registrada en: $removed_log"

  run_cmd "sudo dnf remove -y ${pkgs_to_remove[*]}" "Bloatware eliminado" "Error al eliminar bloatware"
}

install_kde() {
  log_section "üöÄ Instalaci√≥n de entorno de escritorio KDE Plasma"

  ensure_file_exists "$LIST_KDE_PLASMA" || return 1
  log_info "Instalando base de KDE Plasma"
  install_packages "$LIST_KDE_PLASMA"

  configure_sddm
  log_info "Habilitando SDDM como gestor de sesiones"
  run_cmd "sudo systemctl enable sddm" "SDDM habilitado" "Error al habilitar SDDM"
  run_cmd "sudo systemctl set-default graphical.target" "Modo gr√°fico predeterminado" "Error configurando modo gr√°fico"

  # NumLock ya se configura dentro de configure_sddm_numlock
  log_info "NumLock ya configurado por 'configure_sddm_numlock'"

  if [[ -f "$LIST_KDE_BLOATWARE" ]]; then
    log_info "Eliminando bloatware de KDE"
    remove_packages "$LIST_KDE_BLOATWARE"
  else
    log_warn "No se encontr√≥ $LIST_KDE_BLOATWARE. Saltando limpieza."
  fi

  if [[ -f "$LIST_KDE_APPS" ]]; then
    log_info "Instalando aplicaciones adicionales de KDE"
    install_packages "$LIST_KDE_APPS"
  else
    log_warn "No se encontr√≥ $LIST_KDE_APPS. Saltando apps extra."
  fi

  log_success "‚úÖ KDE Plasma instalado y configurado correctamente"
}

reload_plasma(){
  qdbus org.kde.KWin /KWin reconfigure
}

configure_flameshot_with_ocr() {
  log_section "üì∏ Configurando Flameshot + OCR y atajos"

  install_flameshot_deps || return 1
  create_flameshot_ocr_script || return 1
  configure_flameshot_shortcuts || return 1
  create_flameshot_desktop_entry || return 1

  if ! reload_plasma; then
    log_warn "No se pudo recargar Plasma autom√°ticamente. Requiere logout o reinicio"
  fi

  log_success "‚úÖ Flameshot con OCR y atajos configurado correctamente"
}

install_flameshot_deps() {
  local pkgs=(flameshot tesseract tesseract-langpack-spa imagemagick xclip)
  log_section "üì¶ Instalando dependencias de Flameshot: ${pkgs[*]}"
  run_cmd "sudo dnf install -y --allowerasing --skip-broken ${pkgs[*]}" \
    "Dependencias instaladas correctamente" \
    "Fallo al instalar dependencias para Flameshot" || return 1
}


create_flameshot_ocr_script() {
  local desk="${XDG_DESKTOP_DIR:-$HOME/Desktop}"
  local script="$desk/flameshot_ocr.sh"
  log_info "Creando script OCR en: $script"

  mkdir -p "$desk" || {
    log_error "No se pudo crear el escritorio: $desk"
    return 1
  }

  cat > "$script" << 'EOF'
flameshot gui --raw | convert - -resize 400% png:- | \
tesseract stdin stdout | awk 'NR==1{printf "%s", $0} NR>1{printf "\n%s", $0}' | \
xclip -selection clipboard
EOF

  chmod +x "$script" || {
    log_error "No se pudo hacer ejecutable el script: $script"
    return 1
  }

  log_success "Script OCR creado correctamente en: $script"
  return 0
}

configure_flameshot_shortcuts() {
  local file="$HOME/.config/kglobalshortcutsrc"
  log_info "Configurando atajos de teclado con kwriteconfig5"

  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Capture "Print,none,Tomar captura de pantalla" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Configure "Ctrl+Shift+Print,none,Configurar" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Launcher "Ctrl+Print,none,Open launcher" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key _k_friendly_name "Flameshot" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key _launch "none,none,Flameshot" || {
    log_error "No se pudieron escribir los atajos de Flameshot"
    return 1
  }

  kwriteconfig5 --file "$file" --group PlasmaShortcuts --key Print "flameshot gui" || {
    log_error "No se pudo escribir el atajo global de Plasma"
    return 1
  }

  return 0
}

create_flameshot_desktop_entry() {
  local script_path="${XDG_DESKTOP_DIR:-$HOME/Desktop}/flameshot_ocr.sh"
  local desktop_entry="$HOME/.local/share/applications/flameshot-ocr.desktop"

  mkdir -p "$(dirname "$desktop_entry")"
  cat > "$desktop_entry" <<EOF
[Desktop Entry]
Name=Flameshot OCR
Exec=${script_path}
Icon=flameshot
Type=Application
Categories=Utility;
EOF

  log_success "Acceso directo creado en el men√∫: $desktop_entry"
  return 0
}

install_multimedia_lists() {
  log_section "üéµ Instalaci√≥n de aplicaciones multimedia y c√≥decs"

  local lists_to_install=("$LIST_MULTIMEDIA" "$LIST_CODECS")
  for list_file in "${lists_to_install[@]}"; do
    if [[ ! -f "$list_file" ]]; then
      log_warn "Archivo de lista no encontrado: $list_file"
      continue
    fi
    log_info "Instalando desde lista: $list_file"
    if ! install_packages "$list_file"; then
      log_warn "Algunos paquetes de $list_file no se pudieron instalar. Ver log."
    else
      log_success "Paquetes de $list_file instalados correctamente."
    fi
  done
}

install_system_utilities() {
  log_section "üõ†Ô∏è Instalaci√≥n de utilidades del sistema"

  ensure_file_exists "$LIST_UTILITIES" || return 1

  log_info "Instalando herramientas de desarrollo (npm, pip)"
  run_cmd "sudo dnf install -y npm pipx python3-pip" "Herramientas de desarrollo instaladas" "Error al instalar npm/pipx"

  if ! npm list -g electron-store &>/dev/null; then
    run_cmd "sudo npm install -g electron-store" "electron-store instalado" "Error al instalar electron-store"
  else
    log_info "electron-store ya est√° instalado"
  fi

  run_cmd "sudo dnf -y group install development-tools c-development" \
    "Grupos de desarrollo instalados" "Error al instalar grupos de desarrollo"

  log_info "Instalando utilidades generales desde lista"
  install_packages "$LIST_UTILITIES" || log_warn "Fallo parcial en utilidades"

  if ! command -v pipx &>/dev/null; then
    run_cmd "python3 -m pip install --user pipx && python3 -m pipx ensurepath" "pipx instalado" "Fallo al instalar pipx"
  fi

  if ! pipx list | grep -q "lastversion"; then
    run_cmd "pipx install lastversion" "lastversion instalado" "Fallo al instalar lastversion"
  fi

  if ! fc-list | grep -qi "Ubuntu"; then
    run_cmd "sudo dnf copr enable atim/ubuntu-fonts -y && sudo dnf install -y ubuntu-family-fonts" \
      "Fuentes Ubuntu instaladas" "Fallo al instalar fuentes Ubuntu"
  else
    log_info "Fuentes Ubuntu ya presentes"
  fi

  log_info "Verificando herramientas cr√≠ticas"
  for bin in git curl wget zsh bat jq ripgrep fd; do
    if ! command -v "$bin" &>/dev/null; then
      log_warn "El binario $bin no fue encontrado tras la instalaci√≥n"
    fi
  done
}


install_cargo_tools() {
  log_section "üîß Instalaci√≥n de herramientas v√≠a Cargo (Rust)"

  if ! command -v cargo &>/dev/null; then
    log_info "Rust/Cargo no encontrados. Instalando..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y &>> "$LOG_FILE"
    [[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env" && export PATH="$HOME/.cargo/bin:$PATH"
  fi

  if ! command -v rustup &>/dev/null || ! command -v cargo &>/dev/null; then
    log_error "‚ùå Cargo o rustup no disponibles tras la instalaci√≥n. Verifica \$PATH"
    return 1
  fi

  local tools=(cargo-update topgrade)
  local total=${#tools[@]}
  local count=0

  log_info "üõ†Ô∏è Instalando herramientas CLI desde crates.io"
  for tool in "${tools[@]}"; do
    ((count++))
    draw_progress_bar "$count" "$total"
    sleep 0.1
    if command -v "$tool" &>/dev/null; then
      log_info "üîπ $tool ya est√° instalado. Omitiendo."
      continue
    elif [[ -x "$HOME/.cargo/bin/$tool" ]]; then
      log_warn "üîç $tool est√° en ~/.cargo/bin pero no en PATH"
      continue
    fi

    if cargo install --locked "$tool" &>> "$LOG_FILE"; then
      command -v "$tool" &>/dev/null && log_success "‚úîÔ∏è $tool instalado correctamente" ||
        log_warn "‚ö†Ô∏è $tool instalado pero no detectado en PATH."
    else
      log_warn "‚ö†Ô∏è Fallo al instalar $tool con Cargo"
    fi
  done

  if [[ ":$PATH:" != *":$HOME/.cargo/bin:"* ]]; then
    log_warn "‚ö†Ô∏è \$HOME/.cargo/bin no est√° en tu PATH. A√±√°delo manualmente:"
    log_info "echo 'export PATH=\"\$HOME/.cargo/bin:\$PATH\"' >> ~/.bashrc && source ~/.bashrc"
  fi

  log_success "üéØ Herramientas instaladas v√≠a Cargo"
}

install_extra_apps() {
  log_section "üì¶ Instalaci√≥n de aplicaciones adicionales"

  ensure_file_exists "$LIST_EXTRA_APPS" || return 1
  log_info "Instalando paquetes desde lista: $(basename "$LIST_EXTRA_APPS")"
  install_packages "$LIST_EXTRA_APPS" || log_warn "‚ö†Ô∏è Algunos paquetes no se instalaron correctamente"

  if [[ -f "$LIST_KDE_APPS" ]]; then
    log_info "Instalando apps KDE adicionales: $(basename "$LIST_KDE_APPS")"
    install_packages "$LIST_KDE_APPS" || log_warn "‚ö†Ô∏è Fallo parcial en apps KDE adicionales"
  else
    log_warn "Lista de KDE apps no encontrada: $LIST_KDE_APPS"
  fi

  if [[ -f "$LIST_XORG_WORKSPACE" ]]; then
    log_info "Instalando apps KDE adicionales: $(basename "$LIST_XORG_WORKSPACE")"
    install_packages "$LIST_XORG_WORKSPACE" || log_warn "‚ö†Ô∏è Fallo parcial sESION X11"
  else
    log_warn "Lista de KDE apps no encontrada: $LIST_XORG_WORKSPACE"
  fi

  configure_libvirtd
  configure_sddm
  configure_rtc_clock
  install_onlyoffice
  install_flatpak_apps
  configure_vscode

  log_success "‚úÖ Aplicaciones adicionales instaladas y configuradas"
}

perform_system_cleanup() {
  log_section "üßπ Limpieza final del sistema"

  run_cmd "sudo dnf autoremove -y" "Paquetes hu√©rfanos eliminados" "Fallo en autoremove"
  run_cmd "sudo dnf clean all" "Cach√© de DNF limpiada" "Fallo en limpieza de cach√©"

  if command -v flatpak &>/dev/null; then
    run_cmd "flatpak uninstall --unused -y" "Flatpak no usados eliminados" "Fallo en limpieza Flatpak"
  fi

  if command -v bleachbit &>/dev/null; then
    log_info "Limpieza avanzada con BleachBit"
    sudo bleachbit --clean system.cache system.clipboard system.trash &>> "$LOG_FILE" &&
      log_success "BleachBit ejecutado correctamente" ||
      log_warn "BleachBit no pudo completar la limpieza"
  fi

  log_success "üßº Limpieza de sistema completada"
}

configure_libvirtd() {
  log_section "üñ•Ô∏è Habilitando libvirtd para virtualizaci√≥n"

  run_cmd "sudo systemctl start libvirtd" "libvirtd iniciado" "Error al iniciar libvirtd"
  run_cmd "sudo systemctl enable libvirtd" "libvirtd habilitado al arranque" "Error al habilitar libvirtd"
}

configure_sddm_core() {
  log_info "Configurando SDDM como gestor de sesiones"
  run_cmd "sudo systemctl enable sddm" "SDDM habilitado" "Fallo al habilitar SDDM"
  run_cmd "sudo systemctl set-default graphical.target" "Modo gr√°fico como default" "Fallo al establecer graphical.target"
}

configure_sddm_numlock() {
  log_info "Configurando NumLock para SDDM"

  local config_file="/etc/sddm.conf"
  if [[ -f "$config_file" ]]; then
    if grep -q "^\[General\]" "$config_file"; then
      if grep -q "^Numlock=" "$config_file"; then
        sudo sed -i "s/^Numlock=.*/Numlock=on/" "$config_file"
      else
        sudo sed -i "/^\[General\]/a Numlock=on" "$config_file"
      fi
    else
      echo -e "\n[General]\nNumlock=on" | sudo tee -a "$config_file" > /dev/null
    fi
  else
    echo -e "[General]\nNumlock=on" | sudo tee "$config_file" > /dev/null
  fi

  run_cmd "sudo systemctl daemon-reexec" "SDDM recargado" "Error al recargar SDDM"
}

configure_sddm_hide_users() {
  local conf_file="/etc/sddm.conf"
  local username="libvirt-qemu"

  log_info "Ocultando usuario '$username' en SDDM"

  if [[ -f "$conf_file" ]]; then
    if ! grep -q "^\[Users\]" "$conf_file"; then
      echo -e "\n[Users]\nHideUsers=$username" | sudo tee -a "$conf_file" > /dev/null
    elif ! grep -q "^HideUsers=" "$conf_file"; then
      sudo sed -i "/^\[Users\]/a HideUsers=$username" "$conf_file"
    else
      sudo sed -i "s/^HideUsers=.*/HideUsers=$username/" "$conf_file"
    fi
    log_success "Usuario oculto en pantalla de login"
  else
    echo -e "[Users]\nHideUsers=$username" | sudo tee "$conf_file" > /dev/null
    log_success "Archivo sddm.conf creado y usuario oculto"
  fi
}

configure_sddm() {
  log_section "‚öôÔ∏è Configuraci√≥n completa de SDDM"
  configure_sddm_core
  configure_sddm_numlock
  configure_sddm_hide_users
}

configure_rtc_clock() {
  log_info "Configurando el reloj en hora local (RTC)"
  run_cmd "timedatectl set-local-rtc 1" \
    "RTC configurado en hora local" \
    "Fallo al configurar RTC en hora local"
}


install_onlyoffice() {
  log_section "üìù Instalando OnlyOffice Desktop Editors"

  run_cmd "sudo dnf install -y onlyoffice-desktopeditors" \
    "OnlyOffice instalado correctamente" \
    "Error al instalar OnlyOffice"
}

install_flatpak_apps() {
  log_section "üì¶ Instalando aplicaciones Flatpak desde Flathub"

  local flatpak_apps=(
    "com.github.dail8859.NotepadNext"
    "org.localsend.localsend_app"
    "org.strawberrymusicplayer.strawberry"
    "org.nomacs.ImageLounge"
    "com.github.vkohaupt.vokoscreenNG"
    "tv.kodi.Kodi"
    "org.appimage.AppImageLauncher"
    "com.github.manisandro.gImageReader"
  )

  if ! command -v flatpak &>/dev/null; then
    log_info "Flatpak no est√° instalado. Instalando..."
    run_cmd "sudo dnf install -y flatpak" "Flatpak instalado" "Fallo al instalar Flatpak"
  fi

  run_cmd "flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo" \
    "Repositorio Flathub a√±adido" \
    "Error al a√±adir Flathub"

  for app in "${flatpak_apps[@]}"; do
    log_info "Instalando Flatpak: $app"
    if flatpak install -y --noninteractive flathub "$app" &>> "$LOG_FILE"; then
      log_success "$app instalado v√≠a Flatpak"
    else
      log_warn "Fallo al instalar $app"
    fi
  done
}

configure_vscode() {
  log_section "üßë‚Äçüíª Instalando y configurando Visual Studio Code"

  if ! command -v code &>/dev/null; then
    log_info "VSCode no encontrado. Instalando..."
    run_cmd "sudo dnf install -y code" \
      "VSCode instalado correctamente" \
      "Error al instalar VSCode"
  fi

  local vscode_config="$HOME/.config/Code/User"
  mkdir -p "$vscode_config"

  cat > "$vscode_config/settings.json" <<EOF
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "prettier.singleQuote": true,
  "prettier.trailingComma": "all",
  "prettier.jsxSingleQuote": true,
  "prettier.printWidth": 80,
  "editor.fontFamily": "JetBrainsMono Nerd Font,Menlo,Monaco,Courier New,monospace,Noto Color Emoji",
  "editor.fontLigatures": true,
  "editor.fontSize": 14,
  "editor.lineHeight": 24,
  "editor.fontWeight": "400",
  "workbench.colorTheme": "One Monokai"
}
EOF
  log_success "Configuraci√≥n predeterminada de VSCode aplicada"

  local extensions=(
    "azemoh.one-monokai"
    "NarasimaPandiyan.jetbrainsmono"
  )

  for ext in "${extensions[@]}"; do
    log_info "Instalando extensi√≥n: $ext"
    if code --install-extension "$ext" &>> "$LOG_FILE"; then
      log_success "Extensi√≥n $ext instalada"
    else
      log_warn "Fallo al instalar extensi√≥n $ext"
    fi
  done
}

check_dependencies() {
  log_section "üì¶ Verificando dependencias esenciales del sistema..."

  local deps=("curl" "dnf" "wget" "git" "bash")
  local missing=0

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      log_error "‚ùå Dependencia faltante: $dep"
      ((missing++))
    else
      log_success "‚úîÔ∏è Detectado: $dep"
    fi
  done

  if ((missing > 0)); then
    log_error "üö´ $missing dependencias cr√≠ticas faltantes. Abortando."
    exit 1
  fi

  log_info "‚úÖ Todas las dependencias est√°n presentes"
}

add_repositories() {
  log_section "üì¶ A√±adiendo repositorios adicionales"

  try_cmd "A√±adir RPM Fusion Free" \
    sudo dnf install -y "https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm"

  try_cmd "A√±adir RPM Fusion Non-Free" \
    sudo dnf install -y "https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm"

  if ! sudo dnf repolist | grep -q brave-browser; then
    sudo dnf config-manager --add-repo https://brave-browser-rpm-release.s3.brave.com/brave-browser.repo
    sudo rpm --import https://brave-browser-rpm-release.s3.brave.com/brave-core.asc
    log_success "Repositorio Brave a√±adido"
  else
    log_info "Repositorio Brave ya presente"
  fi

  if ! sudo dnf repolist | grep -q 'code'; then
    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
    sudo tee /etc/yum.repos.d/vscode.repo > /dev/null <<EOF
[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc
EOF
    log_success "Repositorio VSCode a√±adido"
  else
    log_info "Repositorio VSCode ya presente"
  fi
}

configure_hardware() {
  log_section "üß† Detectando y configurando hardware del sistema"

  if systemd-detect-virt --quiet; then
    local vm_type
    vm_type=$(systemd-detect-virt)
    log_info "Sistema virtual detectado: $vm_type"
  else
    log_info "Sistema ejecut√°ndose en hardware f√≠sico"
  fi

  if grep -qi "intel" /proc/cpuinfo; then
    log_info "CPU Intel detectada"
    try_cmd "Instalar microc√≥digo Intel" sudo dnf install -y intel-microcode
  elif grep -qi "amd" /proc/cpuinfo; then
    log_info "CPU AMD detectada"
    try_cmd "Instalar microc√≥digo AMD" sudo dnf install -y amd-microcode
  else
    log_warn "No se pudo identificar fabricante de CPU"
  fi

  if lspci | grep -i 'vga' | grep -qi 'nvidia'; then
    log_info "GPU NVIDIA detectada. Se recomienda driver propietario (RPMFusion)"
  elif lspci | grep -i 'vga' | grep -qi 'amd'; then
    log_info "GPU AMD detectada. Mesa deber√≠a ser suficiente"
  elif lspci | grep -i 'vga' | grep -qi 'intel'; then
    log_info "GPU Intel integrada detectada"
  else
    log_warn "GPU principal no identificada"
  fi
}

install_multimedia() {
  log_section "üéµ Instalaci√≥n del stack multimedia (codecs, reproductores, AV)"

  local list="$SCRIPT_DIR/sources/lists/multimedia.list"
  ensure_file_exists "$list" || return 1

  try_cmd "Actualizar grupo multimedia" \
    sudo dnf groupupdate -y sound-and-video

  try_cmd "Instalar paquetes multimedia desde lista" \
    sudo dnf install -y $(grep -vE '^\s*#' "$list" | xargs)

  log_success "‚úÖ Stack multimedia instalado"
}

configure_konsole() {
  log_section "üé® Configuraci√≥n de perfil de Konsole"

  local dotfiles="$SCRIPT_DIR/dotfiles"
  local konsolerc="$dotfiles/konsolerc"
  local profile="$dotfiles/konsole.profile"

  mkdir -p ~/.config ~/.local/share/konsole

  if [[ -f "$konsolerc" ]]; then
    try_cmd "Copiar konsolerc" cp "$konsolerc" ~/.config/konsolerc
  else
    log_warn "Archivo konsolerc no encontrado"
  fi

  if [[ -f "$profile" ]]; then
    try_cmd "Copiar konsole.profile" cp "$profile" ~/.local/share/konsole/Default.profile
  else
    log_warn "Archivo konsole.profile no encontrado"
  fi

  log_success "Konsole configurado correctamente"
}


system_cleanup() {
  log_section "üßπ Realizando limpieza del sistema"

  # Eliminar paquetes hu√©rfanos y no necesarios
  try_cmd "Eliminar paquetes innecesarios" sudo dnf autoremove -y

  # Limpiar cach√© de paquetes descargados
  try_cmd "Limpiar cach√© de DNF" sudo dnf clean all

  # Regenerar metadatos para futuras instalaciones
  try_cmd "Actualizar cach√© de repositorios" sudo dnf makecache

  log_success "Sistema limpio y optimizado"
}