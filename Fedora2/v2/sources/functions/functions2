#!/bin/bash
#===============================================================================
# Archivo: functions.sh
# Proyecto: Fedora Post-Install (KDE)
# DescripciÃ³n: MÃ³dulo de funciones reutilizables para scripts de instalaciÃ³n y postconfiguraciÃ³n
# Autor: Gabriel OmaÃ±a / Initium
# Licencia: MIT
#===============================================================================

# ProtecciÃ³n: Evita que este archivo se ejecute directamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "[ERROR] Este archivo es un mÃ³dulo de funciones y no debe ejecutarse directamente."
  echo "        Por favor, inclÃºyelo con: source ${BASH_SOURCE[0]}"
  exit 1
fi

#===============================================================================
# Variables globales y rutas a listas de paquetes
#===============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LISTS_DIR="${SCRIPT_DIR}/../lists"  # â† CorrecciÃ³n aplicada aquÃ­

LIST_KDE_PLASMA="${LISTS_DIR}/kde_plasma.list"
LIST_KDE_APPS="${LISTS_DIR}/kde_plasma_apps.list"
LIST_KDE_BLOATWARE="${LISTS_DIR}/kde_bloatware.list"
LIST_MULTIMEDIA="${LISTS_DIR}/multimedia.list"
LIST_CODECS="${LISTS_DIR}/codecs.list"
LIST_UTILITIES="${LISTS_DIR}/utilities.list"
LIST_EXTRA_APPS="${LISTS_DIR}/extra_apps.list"

REQUIRED_LISTS=(
  "$LIST_KDE_PLASMA"
  "$LIST_KDE_APPS"
  "$LIST_KDE_BLOATWARE"
  "$LIST_MULTIMEDIA"
  "$LIST_UTILITIES"
  "$LIST_EXTRA_APPS"
)

# Variables de lista individuales (usadas por funciones instaladoras)
kde_plasma="$LIST_KDE_PLASMA"
kde_plasma_apps="$LIST_KDE_APPS"
kde_bloatware="$LIST_KDE_BLOATWARE"
multimedia="$LIST_MULTIMEDIA"
codecs="$LIST_CODECS"
utilities="$LIST_UTILITIES"
extra_apps="$LIST_EXTRA_APPS"

# ValidaciÃ³n de listas necesarias
for list_file in "${REQUIRED_LISTS[@]}"; do
  if [[ ! -f "$list_file" ]]; then
    echo "[ERROR] Lista no encontrada: $list_file"
    return 1
  fi
done


# Colores ANSI
if [[ -t 1 ]]; then
  RED="\033[0;31m"
  GREEN="\033[0;32m"
  YELLOW="\033[1;33m"
  BLUE="\033[1;34m"
  NC="\033[0m"
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; NC=""
fi

setup_colors() {
  if [[ -t 1 ]] && command -v tput >/dev/null 2>&1; then
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    CYAN=$(tput setaf 6)
    BOLD=$(tput bold)
    NC=$(tput sgr0)
  else
    RED=""; GREEN=""; YELLOW=""; BLUE=""; CYAN=""; BOLD=""; NC=""
  fi
}

# Solo la invoca si no estÃ¡ definida
[[ -z "${BOLD:-}" ]] && setup_colors


#===============================================================================
# ConfiguraciÃ³n de logging
#===============================================================================

: "${LOG_FILE:="$HOME/fedora_logs/pkg_manager.log"}"
mkdir -p "$(dirname "$LOG_FILE")"
touch "$LOG_FILE"

#===============================================================================
# VerificaciÃ³n de comandos necesarios
#===============================================================================

REQUIRED_CMDS=(dnf awk xargs sort grep)

for cmd in "${REQUIRED_CMDS[@]}"; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "[ERROR] Comando requerido no encontrado: $cmd" >&2
    exit 1
  fi
done


#===============================================================================
# Funciones utilitarias genÃ©ricas
#===============================================================================

check_command() {
  command -v "$1" &>/dev/null || {
    log_error "Comando requerido no disponible: $1"
    return 1
  }
}

ensure_file_exists() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    log_error "Archivo no encontrado: $file"
    return 1
  fi
}

run_sudo() {
  if ! sudo -n true 2>/dev/null; then
    log_warn "Se requiere autenticaciÃ³n sudo..."
    sudo -v || {
      log_error "No se pudo elevar a sudo. Abortando."
      exit 1
    }
  fi
}

run_cmd() {
  local cmd="$1"
  local success_msg="$2"
  local error_msg="$3"

  if eval "$cmd" &>> "$LOG_FILE"; then
    log_success "$success_msg"
    return 0
  else
    log_error "$error_msg"
    return 1
  fi
}


is_root() {
  [[ "$EUID" -eq 0 ]]
}

draw_progress_bar() {
  local current=$1
  local total=$2
  local width=40
  local percent=$(( current * 100 / total ))
  local filled=$(( current * width / total ))
  local empty=$(( width - filled ))
  local progress_bar

  progress_bar=$(printf "%-${filled}s" "#" | tr ' ' '#')
  progress_bar+=$(printf "%-${empty}s" "-" | tr ' ' '-')
  
  printf "\r[%s] %3d%% (%d/%d)" "$progress_bar" "$percent" "$current" "$total"
  [[ "$current" -eq "$total" ]] && echo ""
}

try_cmd() {
  local desc="$1"; shift
  if "$@"; then
    log_success "âœ”ï¸ $desc completado"
  else
    log_warn "âš ï¸ $desc fallÃ³: $*"
  fi
}


#===============================================================================
# Funciones de instalaciÃ³n y eliminaciÃ³n de paquetes
#===============================================================================

install_packages() {
  local list_file="$1"

  if [[ ! -f "$list_file" ]]; then
    log_warn "Archivo de lista no encontrado: $list_file"
    return 0
  fi

  log_section "ğŸ“¦ InstalaciÃ³n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()
  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))

    # Validar entrada sospechosa
    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "âš ï¸ Entrada invÃ¡lida detectada: '$pkg' â€” omitida"
      continue
    fi

    draw_progress_bar "$count" "$total"

    if [[ "$pkg" == @* ]]; then
      log_info "â¡ï¸ Instalando grupo: $pkg"
      if sudo dnf group install "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"; then
        log_success "âœ… Grupo instalado: $pkg"
      else
        log_warn "âš ï¸ Fallo al instalar grupo: $pkg"
      fi

    elif [[ "$pkg" == *'*'* ]]; then
      log_info "ğŸ” Instalando comodÃ­n: $pkg"
      if sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "âœ… Wildcard instalado: $pkg"
      else
        log_warn "âš ï¸ Fallo wildcard: $pkg"
      fi

    else
      log_info "ğŸ“¦ Instalando: $pkg"
      if sudo dnf install "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "âœ… Instalado: $pkg"
      else
        log_warn "âš ï¸ Fallo paquete: $pkg"
      fi
    fi
  done

  return 0
}


log_section() {
  local title="$1"
  local clean_title="${title//[$'\t\r\n']}"
  local visual_width=${#clean_title}
  local padding=4
  local total_width=$((visual_width + padding))
  local border
  border=$(printf 'â”€%.0s' $(seq 1 "$total_width"))

  echo -e "\n${BLUE}â”Œ$borderâ”${NC}"
  echo -e "${BLUE}â”‚  ${BOLD}${title}${NC}${BLUE}  â”‚${NC}"
  echo -e "${BLUE}â””$borderâ”˜${NC}\n"

  [[ -f "$LOG_FILE" ]] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECTION] $title" >> "$LOG_FILE"
}




remove_packages() {
  local list_file="$1"

  if [[ ! -f "$list_file" ]]; then
    log_warn "Archivo de lista no encontrado: $list_file"
    return 0
  fi

  log_section "ğŸ§¹ EliminaciÃ³n desde lista: $(basename "$list_file")"

  mapfile -t raw_lines < "$list_file"
  local packages=()

  for line in "${raw_lines[@]}"; do
    local clean_line
    clean_line=$(echo "$line" | sed 's/#.*//' | xargs)
    [[ -z "$clean_line" ]] && continue
    packages+=("$clean_line")
  done

  local total=${#packages[@]}
  local count=0
  local dnf_flags=(-y --allowerasing --skip-broken --setopt=skip_if_unavailable=true)

  for pkg in "${packages[@]}"; do
    ((count++))

    if [[ "$pkg" =~ ^-+$ || "$pkg" =~ ^\.+$ ]]; then
      log_warn "âš ï¸ Entrada invÃ¡lida: '$pkg' â€” omitida"
      continue
    fi

    draw_progress_bar "$count" "$total"

    if [[ "$pkg" == @* ]]; then
      log_info "âŒ Eliminando grupo: $pkg"
      if sudo dnf group remove "${dnf_flags[@]}" "${pkg#@}" &>> "$LOG_FILE"; then
        log_success "âœ… Grupo eliminado: $pkg"
      else
        log_warn "âš ï¸ Fallo al eliminar grupo: $pkg"
      fi

    elif [[ "$pkg" == *'*'* ]]; then
      log_info "âŒ Eliminando comodÃ­n: $pkg"
      if sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "âœ… Wildcard eliminado: $pkg"
      else
        log_warn "âš ï¸ Fallo wildcard: $pkg"
      fi

    else
      log_info "âŒ Eliminando paquete: $pkg"
      if sudo dnf remove "${dnf_flags[@]}" "$pkg" &>> "$LOG_FILE"; then
        log_success "âœ… Eliminado: $pkg"
      else
        log_warn "âš ï¸ Fallo al eliminar: $pkg"
      fi
    fi
  done

  return 0
}



add_repositories() {
  log_section "ğŸŒ Agregando y configurando repositorios adicionales"

  declare -A repos=(
    # RPM Fusion
    ["RPM Fusion"]="sudo dnf install -y https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-\$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-\$(rpm -E %fedora).noarch.rpm"

    # WebApp Manager
    ["WebApp Manager"]="sudo dnf -y copr enable refi64/webapp-manager"

    # Brave Browser (incluye importaciÃ³n de GPG key)
    ["Brave Repo"]="
      sudo rpm --import https://brave-browser-rpm-release.s3.brave.com/brave-core.asc &&
      sudo tee /etc/yum.repos.d/brave-browser.repo > /dev/null <<EOF
[brave-browser]
name=Brave Browser
baseurl=https://brave-browser-rpm-release.s3.brave.com/x86_64/
enabled=1
gpgcheck=1
gpgkey=https://brave-browser-rpm-release.s3.brave.com/brave-core.asc
EOF
"

    # OnlyOffice
    ["OnlyOffice"]="
      sudo rpm --import https://download.onlyoffice.com/repo/onlyoffice.key &&
      sudo dnf -y install https://download.onlyoffice.com/repo/centos/main/noarch/onlyoffice-repo.noarch.rpm
    "

    # Personal COPR
    ["Personal COPR"]="sudo dnf -y copr enable ayoungdukie/Personal_Repo"

    # Microsoft GPG + VSCode Repo
    ["VSCode Repo"]="
      sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc &&
      sudo tee /etc/yum.repos.d/vscode.repo > /dev/null <<EOF
[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc
EOF
"
  )

  local total=${#repos[@]}
  local count=0

  # Lista secuencial explÃ­cita para ejecuciÃ³n ordenada
  for name in "RPM Fusion" "WebApp Manager" "Brave Repo" "OnlyOffice" "Personal COPR" "VSCode Repo"; do
    ((count++))
    draw_progress_bar "$count" "$total"
    log_info "ğŸ”§ Configurando repositorio: $name"
    
    if eval "${repos[$name]}" &>> "$LOG_FILE"; then
      log_success "âœ… Repositorio '$name' configurado correctamente."
    else
      log_warn "âš ï¸ Fallo al configurar repositorio: $name. Se continÃºa con los demÃ¡s."
    fi
  done

  draw_progress_bar "$total" "$total"
  log_info "ğŸ”„ Actualizando cachÃ© de DNF..."

  try_cmd "dnf check-update" sudo dnf check-update
  try_cmd "dnf makecache" sudo dnf makecache --refresh

  log_success "ğŸ—‚ï¸ Repositorios configurados y cachÃ© actualizada"
  return 0
}



configure_hardware() {
  show_section "Configurando hardware del sistema"

  # â”€â”€â”€ Paquetes multimedia y cÃ³decs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# InstalaciÃ³n de paquetes multimedia adicionales no cubiertos por listas
log_section "ğŸ”Š InstalaciÃ³n directa de paquetes multimedia complementarios"

# Paquetes individuales
run_cmd "sudo dnf install -y --allowerasing --skip-broken --skip-unavailable \
  ffmpeg-libs \
  gstreamer1-plugin-mpg123 \
  gstreamer1-plugin-openh264 \
  gstreamer1-plugins-bad-free \
  gstreamer1-plugins-bad-freeworld \
  gstreamer1-plugins-base \
  gstreamer1-plugins-good \
  gstreamer1-plugins-ugly \
  libva \
  libva-utils" \
  "Paquetes multimedia instalados (directos)" \
  "Fallo al instalar paquetes multimedia directos"

  # â”€â”€â”€ Soporte grÃ¡fico (GPU) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  show_section "Detectando y configurando GPU"

  mapfile -t gpu_list < <(lspci | grep -iE "VGA|3D controller")

  for gpu_entry in "${gpu_list[@]}"; do
    log_info "GPU detectada: $gpu_entry"

    if echo "$gpu_entry" | grep -qi "Intel"; then
      show_message "Configurando GPU Intel..."
      run_cmd "sudo dnf install -y intel-media-driver vdpau-driver-all libva-utils"         "Drivers de Intel instalados"         "Error al instalar drivers Intel"

    elif echo "$gpu_entry" | grep -qi "AMD"; then
      show_message "Configurando GPU AMD..."

      run_cmd "sudo dnf install -y akmod-amdgpu mesa-va-drivers-freeworld mesa-vdpau-drivers-freeworld vdpau-driver-all libva-utils"         "Drivers de AMD instalados"         "Error al instalar drivers AMD"

      run_cmd "sudo dnf swap -y mesa-va-drivers mesa-va-drivers-freeworld"         "mesa-va-drivers actualizado"         "Error al reemplazar mesa-va-drivers"

      run_cmd "sudo dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld"         "mesa-vdpau-drivers actualizado"         "Error al reemplazar mesa-vdpau-drivers"

    elif echo "$gpu_entry" | grep -qi "NVIDIA"; then
      show_message "Configurando GPU NVIDIA..."

      run_cmd "sudo dnf install -y akmod-nvidia nvidia-driver nvidia-settings nvidia-vaapi-driver vdpau-driver-all libva-utils"         "Drivers de NVIDIA instalados"         "Error al instalar drivers NVIDIA"

      run_cmd "sudo grubby --update-kernel=ALL --args='nvidia-drm.modeset=1'"         "Kernel configurado para NVIDIA (modeset)"         "Error al configurar kernel para NVIDIA"

      log_warn "Es probable que necesite reiniciar para aplicar configuraciÃ³n NVIDIA."

    else
      show_warning "Fabricante de GPU no reconocido: $gpu_entry. Omitiendo configuraciÃ³n."
    fi
  done

# Validar herramientas de aceleraciÃ³n
show_message "Verificando APIs de aceleraciÃ³n de video..."

# Asegurar que las herramientas de diagnÃ³stico estÃ©n instaladas
if ! command -v vaapi-info &>/dev/null; then
  run_cmd "sudo dnf install -y libva-utils" \
    "Herramienta vaapi-info instalada" \
    "Fallo al instalar vaapi-info"
fi

if ! command -v vdpauinfo &>/dev/null; then
  run_cmd "sudo dnf install -y vdpauinfo" \
    "Herramienta vdpauinfo instalada" \
    "Fallo al instalar vdpauinfo"
fi

# Verificar que las APIs estÃ¡n funcionales
for api in vaapi vdpau; do
  if command -v "${api}-info" &>/dev/null; then
    log_success "API $api disponible"
  else
    log_warn "API $api no encontrada. Puede afectar reproducciÃ³n de video."
  fi
done


  # â”€â”€â”€ Soporte para CPU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  show_section "Configurando soporte para CPU"

  hypervisor=$(systemd-detect-virt)
  if [[ "$hypervisor" != "none" ]]; then
    log_info "Sistema virtual detectado ($hypervisor). Omitiendo instalaciÃ³n de microcÃ³digos."
    return 0
  fi

  cpu_name=$(lscpu | grep -Ei 'Model name|Nombre del modelo' | head -n 1)
  log_info "CPU detectada: ${cpu_name:-Desconocida}"

  if echo "$cpu_name" | grep -qi "intel"; then
    show_message "Procesador Intel detectado. Instalando microcÃ³digo..."
    run_cmd "sudo dnf install -y --enablerepo=rpmfusion-nonfree microcode_ctl"       "MicrocÃ³digo de Intel instalado"       "Error al instalar microcÃ³digo de Intel"

  elif echo "$cpu_name" | grep -qi "amd"; then
    show_message "Procesador AMD detectado. Instalando microcÃ³digo..."
    run_cmd "sudo dnf install -y --enablerepo=rpmfusion-nonfree amd-ucode"       "MicrocÃ³digo de AMD instalado"       "Error al instalar microcÃ³digo de AMD"

    log_info "Regenerando initramfs para cargar el microcÃ³digo AMD"
    run_cmd "sudo dracut -f"       "initramfs regenerado correctamente"       "Error al regenerar initramfs (puede requerir reinicio manual)"

  else
    log_warn "No se pudo identificar el fabricante del procesador. Omitiendo instalaciÃ³n de microcÃ³digos."
  fi

  run_cmd "sudo dnf install -y cpuid cpu-x"     "Herramientas de diagnÃ³stico CPU instaladas"     "Error al instalar herramientas de diagnÃ³stico"

  log_info "Verificando microcÃ³digo en kernel..."
  if dmesg | grep -qi microcode; then
    dmesg | grep -i microcode | tee -a "$LOG_FILE"
    log_success "MicrocÃ³digo aplicado detectado en kernel"
  else
    log_warn "No se detectÃ³ microcÃ³digo activo en el kernel (dmesg vacÃ­o)"
  fi
}

clean_kde_bloatware() {
  log_section "Eliminando bloatware de KDE: $LIST_KDE_PLASMA"

  local list_file="${SCRIPT_DIR}/sources/lists/kde_bloatware.list"
  local removed_log="$HOME/fedora_logs/bloatware_removed_$(date +%F_%H-%M-%S).log"

  if [[ ! -f "$list_file" ]]; then
    log_warn "Archivo de bloatware no encontrado: $list_file. Saltando limpieza."
    return 0
  fi

  local pkgs_to_remove=()

  while IFS= read -r pkg || [[ -n "$pkg" ]]; do
    # Limpiar comentarios y lÃ­neas vacÃ­as
    pkg="${pkg%%#*}"
    pkg="$(echo -e "${pkg}" | tr -d '[:space:]')"
    [[ -z "$pkg" ]] && continue

    # Validar si el paquete estÃ¡ instalado
    if rpm -q "$pkg" &>/dev/null; then
      pkgs_to_remove+=("$pkg")
    else
      log_info "Paquete no instalado (omitido): $pkg"
    fi
  done < "$list_file"

  if [[ ${#pkgs_to_remove[@]} -eq 0 ]]; then
    log_info "No se encontraron paquetes de bloatware instalados."
    return 0
  fi

  log_info "Se eliminarÃ¡n ${#pkgs_to_remove[@]} paquetes de bloatware."
  printf "%s\n" "${pkgs_to_remove[@]}" > "$removed_log"
  log_info "Lista guardada en: $removed_log"

  run_cmd "sudo dnf remove -y ${pkgs_to_remove[*]}" \
    "Bloatware de KDE eliminado correctamente" \
    "Fallo al eliminar bloatware de KDE"

  return 0
}

# â”€â”€â”€ InstalaciÃ³n de KDE Plasma â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
install_kde() {
  log_section "ğŸš€ Instalando entorno de escritorio KDE Plasma"

 if [[ ! -f "$LIST_KDE_PLASMA" ]]; then
    log_error "Lista de paquetes de KDE Plasma no encontrada: $LIST_KDE_PLASMA"
    return 1
  fi

  log_info "Iniciando instalaciÃ³n de paquetes base de KDE Plasma"
  install_packages "$LIST_KDE_PLASMA"
  configure_sddm
  log_info "Habilitando SDDM como gestor de sesiones"
  run_cmd "sudo systemctl enable sddm" \
    "SDDM habilitado correctamente" \
    "Error al habilitar SDDM"

  run_cmd "sudo systemctl set-default graphical.target" \
    "Target grÃ¡fico configurado correctamente" \
    "Error al configurar target grÃ¡fico"

  log_info "Configurando NumLock para SDDM"
  if ! set_numlock_sddm; then
    log_warn "FallÃ³ la configuraciÃ³n automÃ¡tica de NumLock en SDDM"
  fi

  if [[ -f "$LIST_KDE_BLOATWARE" ]]; then
    log_info "Eliminando bloatware de KDE"
    remove_packages "$LIST_KDE_BLOATWARE"
  else
    log_warn "Lista de bloatware de KDE no encontrada: $LIST_KDE_BLOATWARE. Omitiendo limpieza."
  fi

  if [[ -f "$LIST_KDE_APPS" ]]; then
    log_info "Instalando aplicaciones adicionales de KDE"
    install_packages "$LIST_KDE_APPS"
  else
    log_warn "Lista de apps adicionales de KDE no encontrada: $LIST_KDE_APPS. Omitiendo."
  fi

  log_success "âœ… KDE Plasma instalado y configurado correctamente"
  return 0
}


configure_flameshot() {
  log_section "ğŸ“¸ Configurando Flameshot + OCR y atajos con kwriteconfig5"

  if ! install_deps; then
    log_error "FallÃ³ la instalaciÃ³n de dependencias de Flameshot"
    return 1
  fi

  if ! create_ocr_script; then
    log_error "Error al crear el script OCR de Flameshot"
    return 1
  fi

  if ! configure_kwrite_shortcuts; then
    log_error "Error al configurar los atajos de teclado con kwriteconfig5"
    return 1
  fi

  if ! create_menu_shortcut; then
    log_error "Error al crear el acceso directo en el menÃº de aplicaciones"
    return 1
  fi

  if ! reload_plasma; then
    log_warn "No se pudo recargar Plasma automÃ¡ticamente. Requiere reinicio o logout"
  fi

  log_success "âœ… Flameshot con OCR y atajos configurado correctamente"
  return 0
}

install_deps() {
  local pkgs=(flameshot tesseract tesseract-langpack-spa imagemagick xclip)
  local msg="Instalando dependencias: ${pkgs[*]}"
  log_section "ğŸ“¦ $msg"
  run_cmd "sudo dnf install -y --allowerasing --skip-broken --skip-unavailable ${pkgs[*]}" \
    "Dependencias instaladas correctamente" \
    "Fallo al instalar dependencias requeridas para Flameshot" || return 1
}

create_ocr_script() {
  local desk="${XDG_DESKTOP_DIR:-$HOME/Desktop}"
  local script="$desk/flameshot_ocr.sh"

  log_info "Creando script OCR en: $script"

  mkdir -p "$desk" || {
    log_error "No se pudo crear el directorio del escritorio: $desk"
    return 1
  }

  cat > "$script" << 'EOF'
#!/usr/bin/env bash
flameshot gui --raw | convert - -resize 400% png:- | \
tesseract stdin stdout | awk 'NR==1{printf "%s", $0} NR>1{printf "\n%s", $0}' | \
xclip -selection clipboard
EOF

  chmod +x "$script" || {
    log_error "No se pudo hacer ejecutable el script: $script"
    return 1
  }

  log_success "Script OCR creado correctamente en: $script"
  return 0
}

configure_kwrite_shortcuts() {
  local file="$HOME/.config/kglobalshortcutsrc"

  log_info "Escribiendo atajos con kwriteconfig5"

  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Capture "Print,none,Tomar captura de pantalla" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Configure "Ctrl+Shift+Print,none,Configurar" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key Launcher "Ctrl+Print,none,Open launcher" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key _k_friendly_name "Flameshot" &&
  kwriteconfig5 --file "$file" --group org.flameshot.Flameshot.desktop --key _launch "none,none,Flameshot" || {
    log_error "No se pudieron escribir los atajos de Flameshot"
    return 1
  }

  kwriteconfig5 --file "$file" --group PlasmaShortcuts --key Print "flameshot gui" || {
    log_error "No se pudo escribir el atajo global de Plasma"
    return 1
  }

  return 0
}

create_menu_shortcut() {
  local script_path="${XDG_DESKTOP_DIR:-$HOME/Desktop}/flameshot_ocr.sh"
  local desktop_entry="$HOME/.local/share/applications/flameshot-ocr.desktop"

  mkdir -p "$(dirname "$desktop_entry")"
  cat > "$desktop_entry" <<EOF
[Desktop Entry]
Name=Flameshot OCR
Exec=${script_path}
Icon=flameshot
Type=Application
Categories=Utility;
EOF

  log_success "Acceso directo creado en el menÃº: $desktop_entry"
  return 0
}

reload_plasma() {
  if command -v qdbus &>/dev/null; then
    qdbus org.kde.KWin /KWin reconfigure && {
      log_success "Atajos recargados en Plasma"
      return 0
    } || {
      log_warn "FallÃ³ recarga por D-Bus; quizÃ¡s requieras logout/login"
      return 1
    }
  else
    log_warn "qdbus no encontrado; reinicia tu sesiÃ³n para aplicar cambios"
    return 1
  fi
}

reload_plasma() {
  if command -v qdbus &>/dev/null; then
    qdbus org.kde.KWin /KWin reconfigure       && log_success "Atajos recargados en Plasma"       || log_warn "FallÃ³ recarga por D-Bus; quizÃ¡s requieras logout/login"
  else
    log_warn "qdbus no encontrado; reinicia tu sesiÃ³n para aplicar cambios"
  fi
}

check_dependencies() {
    local deps=(git wget unzip cmake dnf bleachbit fastfetch)
    local missing=()
    for cmd in "${deps[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_info "Instalando dependencias: ${missing[*]}"
        sudo dnf install -y "${missing[@]}"
    fi
}


# â”€â”€â”€ InstalaciÃ³n de Aplicaciones Multimedia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
install_multimedia() {
  log_section "ğŸµ InstalaciÃ³n de aplicaciones multimedia y cÃ³decs"

  local lists_to_install=("$LIST_MULTIMEDIA" "$LIST_CODECS")

  for list_file in "${lists_to_install[@]}"; do
    if [[ ! -f "$list_file" ]]; then
      log_warn "Archivo de lista no encontrado: $list_file"
      continue
    fi

    log_info "Instalando paquetes desde: $list_file"
    if ! install_packages "$list_file"; then
      log_warn "Algunos paquetes de $list_file no se pudieron instalar. Revisa el log."
    else
      log_success "Paquetes de $list_file instalados correctamente."
    fi
  done

  return 0
}


install_core_apps() {
  log_section "ğŸ§° InstalaciÃ³n de aplicaciones bÃ¡sicas del sistema"
  add_repositories
  install_system_utilities || log_warn "Fallo parcial en instalaciÃ³n de utilidades del sistema"
  install_cargo_tools || log_warn "Fallo parcial en instalaciÃ³n de herramientas vÃ­a Cargo"

  log_success "ğŸ§© Aplicaciones bÃ¡sicas instaladas correctamente"
}

install_system_utilities() {
  log_section "ğŸ› ï¸ InstalaciÃ³n de utilidades del sistema"

  # VerificaciÃ³n del archivo de utilidades
  if [[ ! -f "${LIST_UTILITIES}" ]]; then
    log_error "Archivo de lista de utilidades no encontrado: ${LIST_UTILITIES}"
    return 1
  fi

  log_info "Instalando herramientas de desarrollo (npm, pip)"
  run_cmd "sudo dnf install -y npm pipx python3-pip" "Herramientas de desarrollo instaladas" "Error al instalar herramientas de desarrollo"

  if ! npm list -g electron-store &>/dev/null; then
    run_cmd "sudo npm install -g electron-store" "electron-store instalado globalmente" "Error al instalar electron-store"
  else
    log_info "electron-store ya estÃ¡ instalado"
  fi

  # if ! command -v rustc &>/dev/null; then
  #   log_info "Instalando Rust"
  #   run_cmd "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y" "Rust instalado correctamente" "Error al instalar Rust"
  #   [[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"
  #   [[ ":$PATH:" != *":$HOME/.cargo/bin:"* ]] && export PATH="$HOME/.cargo/bin:$PATH"
  # else
  #   log_info "Rust ya estÃ¡ instalado. Verificando actualizaciones..."
  #   run_cmd "rustup update" "Rust actualizado" "Error al actualizar Rust"
  # fi

  run_cmd "sudo dnf -y group install development-tools c-development" "Grupos de desarrollo instalados" "Error al instalar grupos de desarrollo"
  log_info "Instalando utilidades generales desde lista"
  install_packages "${LIST_UTILITIES}" || log_warn "Fallo parcial al instalar utilidades desde lista"

  if ! command -v pipx &>/dev/null; then
    log_info "Instalando pipx + lastversion"
    run_cmd "python3 -m pip install --user pipx && python3 -m pipx ensurepath" "pipx instalado correctamente" "Fallo al instalar pipx"
  fi

  if ! pipx list | grep -q "lastversion"; then
    run_cmd "pipx install lastversion" "lastversion instalado correctamente" "Fallo al instalar lastversion"
  fi

  if ! fc-list | grep -qi "Ubuntu"; then
    run_cmd "sudo dnf copr enable atim/ubuntu-fonts -y && sudo dnf install -y ubuntu-family-fonts" "Fuentes Ubuntu instaladas" "Fallo al instalar fuentes Ubuntu"
  else
    log_info "Fuentes Ubuntu ya instaladas"
  fi

  log_info "Verificando herramientas crÃ­ticas"
  for bin in git curl wget zsh bat jq ripgrep fd; do
    if ! command -v "$bin" &>/dev/null; then
      log_warn "El binario $bin no fue encontrado tras la instalaciÃ³n"
    fi
  done
}

install_cargo_tools() {
log_section "ğŸ”§ InstalaciÃ³n de herramientas vÃ­a Cargo (Rust)"

# Verifica si cargo estÃ¡ disponible, de lo contrario instala Rust
if ! command -v cargo &>/dev/null; then
  log_info "Rust/Cargo no encontrados. Procediendo a instalaciÃ³n de Rust..."
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y &>> "$LOG_FILE"

  if [[ -f "$HOME/.cargo/env" ]]; then
    source "$HOME/.cargo/env"
    export PATH="$HOME/.cargo/bin:$PATH"
  fi
fi

# Validaciones post-instalaciÃ³n
if ! command -v rustup &>/dev/null; then
  log_error "âŒ rustup no se instalÃ³ correctamente. Abortando instalaciÃ³n de herramientas Cargo."
  return 1
fi

if ! command -v cargo &>/dev/null; then
  log_error "âŒ Cargo no estÃ¡ disponible tras instalaciÃ³n. Verifica si \$HOME/.cargo/bin estÃ¡ en el PATH."
  return 1
fi

# Lista de herramientas a instalar vÃ­a Cargo
local tools=(cargo-update topgrade)
log_info "ğŸ› ï¸ Instalando herramientas CLI desde crates.io"
local total=${#tools[@]}
local count=0

for tool in "${tools[@]}"; do
  ((count++))
  draw_progress_bar "$count" "$total"
  sleep 0.1

  if command -v "$tool" &>/dev/null; then
    log_info "ğŸ”¹ $tool ya estÃ¡ instalado. Omitiendo."
    continue
  elif [[ -x "$HOME/.cargo/bin/$tool" ]]; then
    log_warn "ğŸ” $tool estÃ¡ instalado en ~/.cargo/bin pero no estÃ¡ en PATH"
    continue
  fi

  log_info "ğŸ“¦ Instalando $tool con Cargo..."
  if cargo install --locked "$tool" &>> "$LOG_FILE"; then
    if command -v "$tool" &>/dev/null || [[ -x "$HOME/.cargo/bin/$tool" ]]; then
      log_success "âœ”ï¸ $tool instalado correctamente"
    else
      log_warn "âš ï¸ $tool instalado pero no detectado en PATH."
    fi
  else
    log_warn "âš ï¸ Fallo al instalar $tool con Cargo"
  fi
done

# PATH Check
if [[ ":$PATH:" != *":$HOME/.cargo/bin:"* ]]; then
  log_warn "âš ï¸ \$HOME/.cargo/bin no estÃ¡ en tu PATH. AÃ±Ã¡delo con:"
  log_info "echo 'export PATH=\"\$HOME/.cargo/bin:\$PATH\"' >> ~/.bashrc && source ~/.bashrc"
fi

log_success "ğŸ¯ InstalaciÃ³n de herramientas vÃ­a Cargo completada"

}



install_extra_apps() {
  log_section "Instalando aplicaciones adicionales"

  if [[ ! -f "${extra_apps}" ]]; then
    log_error "Archivo de lista de aplicaciones adicionales no encontrado: ${extra_apps}"
    return 1
  fi
  
  log_info "Instalando paquetes adicionales desde lista: ${extra_apps}"
  install_packages "${extra_apps}" || log_warn "Algunos paquetes adicionales no pudieron instalarse"

  configure_libvirtd
  configure_sddm
  configure_rtc_clock
  install_onlyoffice
  install_flatpak_apps
  install_vscode_with_extensions

  log_success "Aplicaciones adicionales instaladas y configuradas"
  return 0
}

configure_libvirtd() {
  log_info "Habilitando y configurando libvirtd"

  run_cmd "sudo systemctl start libvirtd" \
    "libvirtd iniciado correctamente" \
    "Error al iniciar libvirtd"

  run_cmd "sudo systemctl enable libvirtd" \
    "libvirtd habilitado para el arranque" \
    "Error al habilitar libvirtd"
}

# â”€â”€â”€ Configurar gestor de sesiÃ³n SDDM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
configure_sddm_core() {
  log_info "Habilitando SDDM como gestor de sesiones..."
  run_cmd "sudo systemctl enable sddm" \
    "SDDM habilitado correctamente" \
    "Fallo al habilitar SDDM"

  run_cmd "sudo systemctl set-default graphical.target" \
    "Target grÃ¡fico establecido como predeterminado" \
    "Fallo al establecer graphical.target"
}

# â”€â”€â”€ Configurar NumLock en SDDM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
configure_sddm_numlock() {
  log_info "Configurando NumLock en SDDM..."

  local config_file="/etc/sddm.conf"

  if [[ -f "$config_file" ]]; then
    if grep -q "^\[General\]" "$config_file"; then
      if grep -q "^Numlock=" "$config_file"; then
        sudo sed -i "s/^Numlock=.*/Numlock=on/" "$config_file"
      else
        sudo sed -i "/^\[General\]/a Numlock=on" "$config_file"
      fi
    else
      echo -e "\n[General]\nNumlock=on" | sudo tee -a "$config_file" > /dev/null
    fi
  else
    echo -e "[General]\nNumlock=on" | sudo tee "$config_file" > /dev/null
  fi

  run_cmd "sudo systemctl daemon-reexec" \
    "SDDM recargado correctamente" \
    "Fallo al recargar SDDM (puede requerir reinicio)"
}

# â”€â”€â”€ Ocultar usuarios en pantalla de inicio de SDDM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
configure_sddm_hide_users() {
  local conf_file="/etc/sddm.conf"
  local username="libvirt-qemu"

  log_info "Ocultando usuario '$username' en pantalla de inicio de SDDM"

  if [[ -f "$conf_file" ]]; then
    if ! grep -q "^\[Users\]" "$conf_file"; then
      echo -e "\n[Users]\nHideUsers=$username" | sudo tee -a "$conf_file" > /dev/null
      log_success "SecciÃ³n [Users] creada con usuario oculto"
    elif ! grep -q "^HideUsers=" "$conf_file"; then
      sudo sed -i "/^\[Users\]/a HideUsers=$username" "$conf_file"
      log_success "Directiva HideUsers aÃ±adida"
    else
      sudo sed -i "s/^HideUsers=.*/HideUsers=$username/" "$conf_file"
      log_info "Actualizada directiva HideUsers con nuevo valor: $username"
    fi
  else
    log_warn "Archivo sddm.conf no encontrado. Se crearÃ¡ uno nuevo"
    echo -e "[Users]\nHideUsers=$username" | sudo tee "$conf_file" > /dev/null
    log_success "Archivo sddm.conf creado con usuario oculto"
  fi
}

# â”€â”€â”€ ConfiguraciÃ³n completa de SDDM (nÃºcleo, numlock, ocultar usuarios) â”€â”€
configure_sddm() {
  log_section "âš™ï¸ Configurando SDDM"
  configure_sddm_core
  configure_sddm_numlock
  configure_sddm_hide_users
}

configure_rtc_clock() {
  log_info "Configurando el reloj en hora local (RTC localtime)"

  if timedatectl set-local-rtc 1 &>> "$LOG_FILE"; then
    log_success "RTC configurado para mantener hora local"
  else
    log_warn "No se pudo configurar el RTC en hora local"
  fi
}

install_onlyoffice() {
  log_info "Instalando OnlyOffice Desktop Editors"

  if run_cmd "sudo dnf install -y onlyoffice-desktopeditors" \
    "OnlyOffice instalado correctamente" \
    "Error al instalar OnlyOffice"; then
    log_success "OnlyOffice instalado con Ã©xito"
  else
    log_warn "No se pudo instalar OnlyOffice. Revisa los repositorios o conectividad"
  fi
}

install_flatpak_apps() {
  log_section "Instalando aplicaciones Flatpak desde Flathub"

  local flatpak_apps=(
    "com.github.dail8859.NotepadNext"
    "org.localsend.localsend_app"
    "org.strawberrymusicplayer.strawberry"
    "org.nomacs.ImageLounge"
    "com.github.vkohaupt.vokoscreenNG"
    "tv.kodi.Kodi"
    "org.appimage.AppImageLauncher"
    "com.github.manisandro.gImageReader"
  )

  if ! command -v flatpak &>/dev/null; then
    log_info "Flatpak no estÃ¡ instalado. Instalando Flatpak..."
    run_cmd "sudo dnf install -y flatpak" \
      "Flatpak instalado correctamente" \
      "Fallo al instalar Flatpak"
  fi

  log_info "Asegurando acceso a Flathub"
  run_cmd "flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo" \
    "Repositorio Flathub aÃ±adido correctamente" \
    "Error al aÃ±adir Flathub"

  for app in "${flatpak_apps[@]}"; do
    log_info "Instalando aplicaciÃ³n Flatpak: $app"
    if ! flatpak install -y --noninteractive flathub "$app" &>> "$LOG_FILE"; then
      log_warn "Fallo al instalar $app (Flatpak). Continuando..."
    else
      log_success "$app instalado vÃ­a Flatpak"
    fi
  done

  return 0
}

configure_vscode() {
  log_section "Instalando y configurando Visual Studio Code"

  # Verificar si 'code' estÃ¡ disponible
  if ! command -v code &>/dev/null; then
    log_info "VSCode no encontrado. Intentando instalar desde DNF..."
    run_cmd "sudo dnf install -y code" \
      "Visual Studio Code instalado" \
      "Fallo al instalar Visual Studio Code"
  fi

  # Inicializar entorno si fue la primera ejecuciÃ³n
  log_info "Inicializando configuraciÃ³n de usuario de VSCode"
  local vscode_config="$HOME/.config/Code/User"
  mkdir -p "$vscode_config"

  # Crear configuraciÃ³n predeterminada
  cat > "$vscode_config/settings.json" <<EOF
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "prettier.singleQuote": true,
  "prettier.trailingComma": "all",
  "prettier.jsxSingleQuote": true,
  "prettier.printWidth": 80,
  "editor.fontFamily": "JetBrainsMono Nerd Font,Menlo,Monaco,Courier New,monospace,Noto Color Emoji",
  "editor.fontLigatures": true,
  "editor.fontSize": 14,
  "editor.lineHeight": 24,
  "editor.fontWeight": "400",
  "workbench.colorTheme": "One Monokai"
}
EOF
  log_success "Archivo de configuraciÃ³n VSCode generado"

  # Instalar extensiones Ãºtiles
  declare -a extensions=(
    "azemoh.one-monokai"
    "NarasimaPandiyan.jetbrainsmono"
  )

  for ext in "${extensions[@]}"; do
    log_info "Instalando extensiÃ³n: $ext"
    if ! code --install-extension "$ext" &>> "$LOG_FILE"; then
      log_warn "ExtensiÃ³n $ext no pudo instalarse"
    else
      log_success "ExtensiÃ³n $ext instalada"
    fi
  done

  return 0
}